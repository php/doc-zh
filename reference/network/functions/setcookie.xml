<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: d62d6b01c4d00cfebb7737054d19ba7ce26132d0 Maintainer: daijie Status: ready -->
<!-- Reviewed: no -->

<refentry xml:id="function.setcookie" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <refnamediv>
  <refname>setcookie</refname>
  <refpurpose>发送 Cookie</refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>setcookie</methodname>
   <methodparam><type>string</type><parameter>name</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>value</parameter><initializer>""</initializer></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>expire</parameter><initializer>0</initializer></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>path</parameter><initializer>""</initializer></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>domain</parameter><initializer>""</initializer></methodparam>
   <methodparam choice="opt"><type>bool</type><parameter>secure</parameter><initializer>false</initializer></methodparam>
   <methodparam choice="opt"><type>bool</type><parameter>httponly</parameter><initializer>false</initializer></methodparam>
  </methodsynopsis>
  <para>
   <function>setcookie</function> 定义了 Cookie，会和剩下的 HTTP 首部一起发送给客户端。
   和其他 HTTP 首部一样，Cookie 必须在脚本产生任意输出<emphasis>之前</emphasis>发送（由于协议的限制）。
   需要在产生任何输出（包括 <literal>&lt;html&gt;</literal> 和 <literal>&lt;head&gt;</literal> 或者空格）之前调用本函数。
  </para>
  <para>
   一旦 Cookie 被设置后，可以在下次打开页面时，使用 <varname>$_COOKIE</varname> 读取。
   Cookie 的值也同样存在于 <varname>$_REQUEST</varname>。
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <link xlink:href="&url.rfc;6265">RFC 6265</link> 提供了 <function>setcookie</function> 每个参数的参考标准。
   <variablelist>
    <varlistentry>
     <term><parameter>name</parameter></term>
     <listitem>
      <para>
       Cookie 名称。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>value</parameter></term>
     <listitem>
      <para>
       Cookie 的值。
       这个值储存于用户的电脑里，请勿储存敏感信息。
       
       比如 <parameter>name</parameter> 是 <literal>'cookiename'</literal>，
       这个值就可以通过 <varname>$_COOKIE['cookiename']</varname> 获取。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>expire</parameter></term>
     <listitem>
      <para>
       Cookie 的过期时间。
       这是个 Unix 时间戳，就是从 Unix 纪元以来（格林威治时间 1970 年 1 月 1 日 00:00:00）的秒数。
       也就是说，基本可以用 <function>time</function> 函数返回的结果加上希望过期的秒数。
       或者也可以用 <function>mktime</function>。
       
       设置 Cookie 在 30 天后过期：<literal>time()+60*60*24*30</literal>。
       如果设置成零，或者忽略参数， Cookie 会在会话结束时过期（也就是关掉浏览器时）。
      </para>
      <para>
       <note>
        <para>
          你可能注意到了，<parameter>expire</parameter> 使用 Unix 时间戳而非 <literal>Wdy, DD-Mon-YYYY
         HH:MM:SS GMT</literal> 这样的日期格式，是因为 PHP 内部作了转换。
        </para>
       </note>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>
       Cookie 有效的服务器路径。
       设置成 <literal>'/'</literal>，Cookie 对整个域名 <parameter>domain</parameter> 有效。
       
       如果设置成 <literal>'/foo/'</literal>， Cookie 仅仅对 <parameter>domain</parameter> 中 <literal>/foo/</literal> 目录和子目录有效（比如 <literal>/foo/bar/</literal>）。
       默认值是设置 Cookie 时的当前目录。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>domain</parameter></term>
     <listitem>
      <para>
       Cookie 的有效域名/子域名。
       设置成一个子域名（例如 <literal>'www.example.com'</literal>），会使 Cookie 对这个子域名和它的三级域名有效（例如 w2.www.example.com）。
       要让 Cookie 对整个域名有效（包括它的全部子域名），只要把这个值设置成域名就可以了（这个例子里是 <literal>'example.com'</literal>）。
      </para>
      <para>
       旧版浏览器仍然在使用废弃的 <link xlink:href="&url.rfc;2109">RFC 2109</link>，
       需要一个前置的点 <literal>.</literal> 来匹配所有子域名。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>secure</parameter></term>
     <listitem>
      <para>
       设置这个 Cookie 是否需要仅仅通过安全的 HTTPS 连接传给客户端。
       设置成 &true; 时，只有安全连接存在时才会设置 Cookie。
       如果是在服务器端，程序员需要仅仅在安全连接上发送此类 Cookie
       （通过 <varname>$_SERVER["HTTPS"]</varname> 判断）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>httponly</parameter></term>
     <listitem>
      <para>
       设置成 &true;，Cookie 仅可通过 HTTP 协议访问。
       这意思就是 Cookie 无法通过类似 JavaScript 这样的脚本语言访问。
       建议此设置，可有效减少 XSS 攻击时的身份窃取行为（虽然不是所有浏览器都支持），不过这个说法经常有争议。
       PHP 5.2.0 中添加。
       &true; 或 &false;
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   如果在调用本函数以前就产生了输出，<function>setcookie</function> 会调用失败并返回 &false;。
   如果 <function>setcookie</function> 成功运行，返回 &true;。当然，它的意思并非用户是否已接受 Cookie。
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   发送 Cookie 的几个例子：
   <example>
    <title><function>setcookie</function> 发送例子</title>
    <programlisting role="php">
<![CDATA[
<?php
$value = 'something from somewhere';

setcookie("TestCookie", $value);
setcookie("TestCookie", $value, time()+3600);  /* 1 小时过期  */
setcookie("TestCookie", $value, time()+3600, "/~rasmus/", "example.com", 1);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   注意：在发送 Cookie 时，值的部分会被自动 urlencode 编码。收到 Cookie 时，会自动解码，并赋值到可变的 Cookie 名称上。
   如果不想被编码，可以使用 <function>setrawcookie</function> 代替——如果你的 PHP 版本是 5 及以上。
   在脚本里查看我们的测试 Cookie 的内容，使用下面的一个例子：
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// 打印一个单独的 Cookie
echo $_COOKIE["TestCookie"];

//  debug/test 查看所有 Cookie 的另一种方式
print_r($_COOKIE);
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   <example>
    <title><function>setcookie</function> 删除例子</title>
    <para>
     要删除一个 Cookie，应该设置过期时间为过去，触发浏览器的删除机制。
     下面的例子展示了如何删除上个例子里的 Cookie：
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// 设置过期时间为一个小时前
setcookie("TestCookie", "", time() - 3600);
setcookie("TestCookie", "", time() - 3600, "/~rasmus/", "example.com", 1);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title><function>setcookie</function> 和数组</title>
    <para>
     通过带 array 标记的 Cookie 名称，也可以把 Cookie 设置成数组。
     如果有数组元素，可以把它放进 Cookie 里；
     脚本接收到时，Cookie 名称里的值会是一个数组：
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// 设置 Cookie
setcookie("cookie[three]", "cookiethree");
setcookie("cookie[two]", "cookietwo");
setcookie("cookie[one]", "cookieone");

// 网页刷新后，打印出以下内容
if (isset($_COOKIE['cookie'])) {
    foreach ($_COOKIE['cookie'] as $name => $value) {
        $name = htmlspecialchars($name);
        $value = htmlspecialchars($value);
        echo "$name : $value <br />\n";
    }
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
three : cookiethree
two : cookietwo
one : cookieone
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>5.5.0</entry>
       <entry>
        发送给客户端的 Set-Cookie 首部现在会包含 Max-Age 属性。
       </entry>
      </row>
      <row>
       <entry>5.2.0</entry>
       <entry>
        添加 <parameter>httponly</parameter> 参数。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    为了在调用本函数前发送内容输出，可以使用输出缓冲：让输出的内容在服务器里缓冲起来，
    直至真正发送给浏览器。
    可在脚本里调用 <function>ob_start</function> 和 <function>ob_end_flush</function>，
    或设置 <literal>output_buffering</literal> &php.ini; 或服务器配置文件里的配置指令。
   </para>
  </note>
  <note>
   <para>
    如果 PHP 指令 <link linkend="ini.register-globals">register_globals</link>
    设置成 <literal>on</literal>，Cookie 值会自动设置成变量。
    下面的例子里会存在 <varname>$TestCookie</varname>。
    我们推荐你使用 <varname>$_COOKIE</varname>。
   </para>
  </note>
  <para>
   注意避坑：
   <itemizedlist>
    <listitem>
     <simpara>
      在页面（ Cookie 可见的页面）下次刷新前，Cookie 不会生效。
      测试 Cookie 是否已经成功设置，需要在下次页面加载时，Cookie 过期前检测。
      过期时间是通过 <parameter>expire</parameter> 参数设置的。
      直接调用 <literal>print_r($_COOKIE);</literal> 调试检测 Cookie 是个不错的方式。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      为同一个参数再次设置 Cookie 前，必须先把它删掉。
      如果值的参数是空字符串或 &false;，同时其他参数和上次调用 setcookie 一样，
      则指定的名称会被远程客户端删除。
      这在内部的实现是，将值设置成 'deleted'，同时过期时间是一年前。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      因为设置值成 &false; 会导致 Cookie 被删除，所以应该避免使用布尔值。
      作为代替，0 是 &false;，1 是 &true;。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Cookie 名称可以设置成数组名称，PHP 脚本里会是数组，
      但用户系统里储存的是单独分开的 Cookie。 
      可以考虑使用 <function>explode</function> 为一个 Cookie 设置多个名称和值。
      不建议将 <function>serialize</function> 用于此处，因为它会导致安全漏洞。
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <simpara>
   多次调用 <function>setcookie</function> 会按调用顺序执行。
  </simpara>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>header</function></member>
    <member><function>setrawcookie</function></member>
    <member><link linkend="features.cookies">Cookie 章节</link></member>
    <member><link xlink:href="&url.rfc;6265">RFC 6265</link></member>
    <member><link xlink:href="&url.rfc;2109">RFC 2109</link></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
