<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 86d3fb841e0206e2588896ad3c21432333535848 Maintainer: mowangjuanzi Status: partial -->
<section xmlns="http://docbook.org/ns/docbook" xml:id="pdo.constants.fetch-modes">
 <title>获取模式</title>

 <simpara>
  参见 <literal>PDO::FETCH_ORI_*</literal> 游标常量的<link linkend="pdo.constants.cursors">游标常量</link>。
 </simpara>

 <section xml:id="pdo.fetch-modes.basic" annotations="chunk:false">
  <title>基本获取模式</title>
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>获取模式</entry>
      <entry>摘要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_DEFAULT</constant>
      </entry>
      <entry>
       用于当前默认获取模式的特殊值。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_ASSOC</constant>
      </entry>
      <entry>
       仅按列名索引的数组。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_BOTH</constant>（默认）
      </entry>
      <entry>
       同时按列号和列名索引的数组。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NAMED</constant>
      </entry>
      <entry>
       保留重复列的 <constant>PDO::FETCH_ASSOC</constant> 变体。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NUM</constant>
      </entry>
      <entry>
       仅按列号索引的数组。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_COLUMN</constant>
      </entry>
      <entry>
       单列。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_KEY_PAIR</constant>
      </entry>
      <entry>
       键值对，按第一列索引。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_FUNC</constant>
      </entry>
      <entry>

       使用函数创建返回值。（仅适用于 <methodname>PDOStatement::fetchAll</methodname>）
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_OBJ</constant>
      </entry>
      <entry>
       匿名（<classname>stdClass</classname>）对象。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASS</constant>
      </entry>
      <entry>
       指定类的对象。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.class-flags" annotations="chunk:false">
  <title>PDO::FETCH_CLASS 选项</title>

  <simpara>
   这些模式用于在使用 <constant>PDO::FETCH_CLASS</constant> 时实现选项。
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>获取模式</entry>
      <entry>摘要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASSTYPE</constant>
      </entry>
      <entry>
       使用第一列作为类名。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_PROPS_LATE</constant>
      </entry>
      <entry>
       在设置属性之前调用构造方法。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_SERIALIZE</constant>
      </entry>
      <entry>
       使用 PHP 序列化数据。自 PHP 8.1.0 起弃用。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.single" annotations="chunk:false">
  <title>单结果模式</title>

  <simpara>
   以下模式无法与 <methodname>PDOStatement::fetchAll</methodname> 一起使用。
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>获取模式</entry>
      <entry>摘要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_BOUND</constant>
      </entry>
      <entry>
       将值绑定到指定变量。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_INTO</constant>
      </entry>
      <entry>
       更新现有对象。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_LAZY</constant>
      </entry>
      <entry>
       通过 <classname>PDORow</classname> 实现延迟获取，以支持类似数组和对象的访问方式。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.grouped" annotations="chunk:false">
  <title>
   <methodname>PDOStatement::fetchAll</methodname> 的特殊行为 flag
  </title>

  <simpara>
   以下适用于多结果的特殊模式仅与 <methodname>PDOStatement::fetchAll</methodname> 兼容，且不适用于某些其他获取模式。详情请参阅完整文档。
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>获取模式</entry>
      <entry>摘要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_GROUP</constant>
      </entry>
      <entry>
       结果按第一列分组。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_UNIQUE</constant>
      </entry>
      <entry>
       结果按第一列（唯一）索引。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.duplicate-names" annotations="chunk:false">
  <title>重复列名的处理方式</title>
  <simpara>
   结果中可能包含使用相同名称的多个列。例如，在连接两个表时，这两个表都包含具有相同名称的列。
  </simpara>
  <simpara>
   由于 PHP 的数组和对象等结构不支持使用相同名称的多个 key 或属性，返回的数组或对象将仅包含其中一个使用相同名称的值。
  </simpara>
  <simpara>
   对于重复名称，指定返回哪个值应视为未定义行为。
  </simpara>
  <simpara>
   为避免此问题，可以使用别名手动命名列。例如：
  </simpara>
  <informalexample>
   <programlisting role="sql">
<![CDATA[
SELECT table1.created_at AS t1_created_at,
       table2.created_at AS t2_created_at
FROM table1
JOIN table2 ON table1.table2id = table2.id
]]>
   </programlisting>
  </informalexample>
  <simpara>
   参见 <constant>PDO::FETCH_NAMED</constant>、<constant>PDO::ATTR_FETCH_TABLE_NAMES</constant> 和
   <constant>PDO::ATTR_FETCH_CATALOG_NAMES</constant>。
  </simpara>
 </section>

 <section xml:id="pdo.fetch-modes.default" annotations="chunk:false">
  <title>设置默认获取模式</title>
  <simpara>
   可以使用 <methodname>PDO::__construct</methodname> 或 <methodname>PDO::setAttribute</methodname>，通过
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant> 设置所有查询的默认获取模式。
  </simpara>
  <simpara>
   可以使用 <methodname>PDOStatement::setFetchMode</methodname> 为特定语句设置默认获取模式。这会影响作为预处理语句的再次使用以及迭代（使用
   <link linkend="control-structures.foreach">foreach</link>）。
  </simpara>
  <caution>
   <simpara>
    <methodname>PDOStatement::setAttribute</methodname> 无法用于设置默认获取模式。它仅接受特定驱动程序的属性，并会静默忽略未识别的属性。
   </simpara>
  </caution>
 </section>

 <section xml:id="pdo.constants.fetch-default" annotations="chunk:false">
  <title>PDO::FETCH_DEFAULT (<type>int</type>)</title>
  <simpara>
   自 PHP 8.0.7 起可用。
  </simpara>
  <simpara>
   这是一个特殊值，<classname>PDOStatement</classname> 是当前默认使用的获取模式。当扩展 <classname>PDOStatement</classname> 以与
   <constant>PDO::ATTR_STATEMENT_CLASS</constant> 一起使用时，它作为方法参数的默认值非常有用。
  </simpara>
  <para>
   此值不能与 <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant> 一起使用。
  </para>
 </section>

 <section xml:id="pdo.constants.fetch-assoc" annotations="chunk:false">
  <title>PDO::FETCH_ASSOC (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_ASSOC</constant> 返回仅按列名索引的数组。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-both" annotations="chunk:false">
  <title>PDO::FETCH_BOTH (<type>int</type>)</title>
  <simpara>
   这是默认的获取模式。
  </simpara>
  <simpara>
   <constant>PDO::FETCH_BOTH</constant> 返回同时列号和列名索引的数组。这意味着每一行结果中的每个返回值都是重复的。
  </simpara>
  <simpara>
   列号从 0 开始，由查询结果中的列顺序决定，而不是表中定义的列顺序。
  </simpara>
  <note>
   <simpara>
    不建议使用数字列索引，因为当查询发生更改时，或者在使用 <literal>SELECT *</literal>
    时表结构发生更改，列索引可能会发生变化。
   </simpara>
  </note>
  <note>
   <simpara>
    在多个返回列使用相同名称的情况下，按名称索引的条目数量可能与按数字索引的条目数量不匹配。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_BOTH);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [id] => 104,
    [0] => 104,
    [name] => Chris,
    [1] => Chris,
    [country] => Ukraine,
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-named" annotations="chunk:false">
  <title>PDO::FETCH_NAMED (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NAMED</constant> 返回的结果格式与
   <constant>PDO::FETCH_ASSOC</constant> 相同，但当多个列使用相同名称时，所有值将以列表形式返回。
  </simpara>
  <simpara>
   有关重复列名的处理及其替代方法的更多信息，请参阅上文关于<link linkend="pdo.fetch-modes.duplicate-names">重复名称处理的部分</link>。
  </simpara>
  <simpara>
   重复值的返回顺序应视为未定义。无法确定每个值的来源。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query(
    "SELECT users.*, referrer.name
     FROM users
     LEFT JOIN users AS referrer ON users.referred_by = referrer.userid
     WHERE userid = 109"
);
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 109
    [name] => Array
        (
            [0] => Toni
            [1] => Chris
        )
    [country] => Germany
    [referred_by] = 104
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-num" annotations="chunk:false">
  <title>PDO::FETCH_NUM (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NUM</constant> 返回的数组仅按列号索引。列号从 0
   开始，并由查询中的结果列顺序决定，而不是（例如）表中定义的列顺序。
  </simpara>
  <note>
   <simpara>
    不建议使用数字列索引，因为当查询发生更改时，或者在使用 <literal>SELECT *</literal>
    时表结构发生更改，该索引可能会发生变化。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => 104
    [1] => Chris
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-column" annotations="chunk:false">
  <title>PDO::FETCH_COLUMN (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_COLUMN</constant> 用于返回单列的值。可通过 <methodname>PDOStatement::setFetchMode</methodname>
   或 <methodname>PDOStatement::fetchAll</methodname> 的第二个参数指定要返回的列。
  </simpara>
  <simpara>
   若指定的列不存在，将抛出 <classname>ValueError</classname>。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN);
print_r($row);

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN, 1);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Chris
    [1] => Jamie
    [2] => Robin
)

Array
(
    [0] => Ukraine
    [1] => England
    [2] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-key-pair" annotations="chunk:false">
  <title>PDO::FETCH_KEY_PAIR (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_KEY_PAIR</constant> 返回以第一列为索引的键值对，结果必须仅包含两列。此获取模式仅适用于
   <methodname>PDOStatement::fetchAll</methodname>。
  </simpara>
  <note>
   <simpara>
    若第一列不唯一，将丢失部分值，具体哪些值会丢失属于未定义行为。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_KEY_PAIR);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Chris] => Ukraine
    [Jamie] => England
    [Robin] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-func" annotations="chunk:false">
  <title>PDO::FETCH_FUNC (<type>int</type>)</title>
  <simpara>
   指定用于创建返回值的函数。此模式仅可用于 <methodname>PDOStatement::fetchAll</methodname>。
  </simpara>
  <simpara>
   该函数以各列的值作为参数接收。因无法获知某个值原本关联的列名，因此必须确保查询中的列顺序与函数参数顺序一致。
  </simpara>
  <note>
   <simpara>
    <constant>PDO::FETCH_GROUP</constant> 和 <constant>PDO::FETCH_UNIQUE</constant> 的效果会在调用该函数之前应用于结果。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function valueCreator($col1, $col2, $col3)
{
    return [
        'col1' => $col1,
        'col2' => strtoupper($col2),
        'col3' => $col3,
        'customKey' => 'customValue',
    ];
}

$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_FUNC, valueCreator(...));
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [col1] => 104
            [col2] => SAM
            [col3] => Ukraine
            [customKey] => customValue
        )

    [1] => Array
        (
            [col1] => 105
            [col2] => JAMIE
            [col3] => England
            [customKey] => customValue
        )

    [2] => Array
        (
            [col1] => 107
            [col2] => ROBIN
            [col3] => Germany
            [customKey] => customValue
        )

)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-obj" annotations="chunk:false">
  <title>PDO::FETCH_OBJ (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_OBJ</constant> 返回 <classname>stdClass</classname> 对象。
  </simpara>
  <simpara>
   参见 <methodname>PDOStatement::fetchObject</methodname> 和
   <constant>PDO::FETCH_CLASS</constant>。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_OBJ);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
stdClass Object
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-class" annotations="chunk:false">
  <title>PDO::FETCH_CLASS (<type>int</type>)</title>
  <simpara>
   返回指定类的对象。有关附加行为，请参见<link linkend="pdo.fetch-modes.class-flags">选项 flag</link>。
  </simpara>
  <simpara>
   如果返回的列名与对象中已存在的属性名称不匹配，将会动态声明该属性。已废弃此行为，并自 PHP 9.0 起会引发错误。
  </simpara>
  <simpara>
   参见 <methodname>PDOStatement::fetchObject</methodname>。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-classtype" annotations="chunk:false">
  <title>PDO::FETCH_CLASSTYPE (<type>int</type>)</title>
  <simpara>
   此获取模式仅可与 <constant>PDO::FETCH_CLASS</constant>（及<link
   linkend="pdo.fetch-modes.class-flags">其他选项</link>）结合使用。
  </simpara>
  <simpara>
   使用此获取模式时，PDO 会将返回结果的第一列作为要实例化的类名。
  </simpara>
  <simpara>
   若指定的类未找到，将返回 <classname>stdClass</classname> 对象，且不产生警告或错误。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT 'TestEntity', userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-props-late" annotations="chunk:false">
  <title>PDO::FETCH_PROPS_LATE (<type>int</type>)</title>
  <simpara>
   此获取模式仅可与 <constant>PDO::FETCH_CLASS</constant>（及<link
   linkend="pdo.fetch-modes.class-flags">其他选项</link>）结合使用。
  </simpara>
  <simpara>
   使用此获取模式时，会在属性赋值前调用构造方法。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? No
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-serialize" annotations="chunk:false">
  <title>PDO::FETCH_SERIALIZE (<type>int</type>)</title>
  &warn.deprecated.feature-8-1-0;
  <simpara>
   此获取模式仅可与 <constant>PDO::FETCH_CLASS</constant>（及<link
   linkend="pdo.fetch-modes.class-flags">其他选项</link>）结合使用。
  </simpara>
  <simpara>
   使用此获取模式时，指定的类必须实现 <interfacename>Serializable</interfacename>。
  </simpara>
  <caution>
   <simpara>
    此功能不支持包含完整序列化对象（通过 <function>serialize</function> 生成）的字符串。
   </simpara>
  </caution>
  <caution>
   <simpara>
    此获取模式不会调用构造方法。
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity implements Serializable
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with " . count(func_get_args()) . " args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }

    public function serialize()
    {
        return join(
            "|",
            [$this->userid, $this->name, $this->country, $this->referred_by_userid]
        );
    }

    public function unserialize(string $data)
    {
        $parts = explode("|", $data);
        $this->userid = (int) $parts[0];
        $this->name = $parts[1];
        $this->country = $parts[2];

        $refId = $parts[3];
        $this->referred_by_userid = ($refId === "" ? null : (int) $refId);
    }
}

print "Set up record (constructor called manually):\n";
$db->exec(
    "CREATE TABLE serialize (
        sdata TEXT
    )"
);

$origObj = new TestEntity();
$origObj->userid = 200;
$origObj->name = 'Seri';
$origObj->country = 'Syria';
$origObj->referred_by_userid = null;

$insert = $db->prepare("INSERT INTO serialize (sdata) VALUES (:sdata)");
$insert->execute(['sdata' => $origObj->serialize()]);

print "\nRetrieve result:\n";
$query = "SELECT sdata FROM serialize";
$stmt = $db->query($query);
// NOTE: Constructor is never called!
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_SERIALIZE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Deprecated: TestEntity implements the Serializable interface, which is deprecated. Implement __serialize() and __unserialize() instead (or in addition, if support for old PHP versions is necessary) in Standard input code on line 2
Set up record (constructor called manually):
Constructor called with 0 args
Properties set when constructor called? No

Retrieve result:
Deprecated: PDOStatement::setFetchMode(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 58

Deprecated: PDOStatement::fetch(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 59
object(TestEntity)#5 (4) {
  ["userid"]=>
  int(200)
  ["name"]=>
  string(4) "Seri"
  ["country"]=>
  string(5) "Syria"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-bound" annotations="chunk:false">
  <title>PDO::FETCH_BOUND (<type>int</type>)</title>
  <simpara>
   此获取模式无法与 <methodname>PDOStatement::fetchAll</methodname> 一起使用。
  </simpara>
  <simpara>
   此获取模式不直接返回结果，而是将值绑定到通过 <methodname>PDOStatement::bindColumn</methodname>
   指定的变量，所调用的获取方法返回 &true;。
  </simpara>
  <note>
   <simpara>
    使用预处理语句时，为确保正确运行，变量必须在查询执行后进行绑定。
   </simpara>
  </note>
  <programlisting role="php">
<![CDATA[
<?php
$query = "SELECT users.userid, users.name, users.country, referrer.name
    FROM users
    LEFT JOIN users AS referrer ON users.referred_by_userid = referrer.userid";
$stmt = $db->prepare($query);
$stmt->execute();

$stmt->bindColumn('userid', $userId);
$stmt->bindColumn('name', $name);
$stmt->bindColumn('country', $country);
// Bind by column position to resolve duplicated column name
// To avoid this breaking if the query is changed, use an SQL alias instead
// For example: referrer.name AS referrer_name
$stmt->bindColumn(4, $referrerName);

while ($stmt->fetch(\PDO::FETCH_BOUND)) {
    print join("\t", [$userId, $name, $country, ($referrerName ?? 'NULL')]) . "\n";
}
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
104	Chris	Ukraine	NULL
105	Jamie	England	NULL
107	Robin	Germany	Chris
108	Sean	Ukraine	NULL
109	Toni	Germany	NULL
110	Toni	Germany	NULL
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-into" annotations="chunk:false">
  <title>PDO::FETCH_INTO (<type>int</type>)</title>
  <simpara>
   此获取模式无法与 <methodname>PDOStatement::fetchAll</methodname> 一起使用。
  </simpara>
  <simpara>
   此获取模式会更新指定对象中的属性。成功后，将返回该对象。
  </simpara>
  <simpara>
   如果返回的列名对应的属性不存在，则会动态声明该属性。已弃用此行为，自 PHP 9.0 起会导致错误。
  </simpara>
  <simpara>
   属性必须是 <literal>public</literal> 并且不能是 <literal>readonly</literal>。
  </simpara>
  <caution>
   <simpara>
    若不在每次获取记录之间使用 <methodname>PDOStatement::setFetchMode</methodname>，则无法更改待更新的对象。
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;
}

$obj = new TestEntity();
$stmt->setFetchMode(\PDO::FETCH_INTO, $obj);

$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-lazy" annotations="chunk:false">
  <title>PDO::FETCH_LAZY (<type>int</type>)</title>
  <simpara>
   此获取模式无法与 <methodname>PDOStatement::fetchAll</methodname> 一起使用。
  </simpara>
  <simpara>
   此获取模式返回 <classname>PDORow</classname>
   对象，以延迟方式检索，并同时支持类似数组和对象访问值的方式（即结合了
   <constant>PDO::FETCH_BOTH</constant> 与 <constant>PDO::FETCH_OBJ</constant> 的行为）。
  </simpara>
  <simpara>
   这种方式可在 PHP 端实现对数据库服务器上非缓冲结果的内存高效访问。PDO
   是否对结果使用客户端缓冲，取决于所使用的数据库特定驱动及其配置。
  </simpara>
  <caution>
   <simpara>
    <classname>PDORow</classname> 在访问未定义的属性或 key 时会返回
    <literal>NULL</literal>，且不产生任何错误或警告，这可能导致拼写错误或查询未返回预期数据等问题更难发现和调试。
   </simpara>
  </caution>
  <caution>
   <simpara>
    返回的 <classname>PDORow</classname> 对象在每次获取结果时都会更新。
   </simpara>
  </caution>
  <programlisting role="php">
<![CDATA[
<?php
$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch(\PDO::FETCH_LAZY);

print "ID: ". $result[0] ."\n";
print "Name: {$result->name}\n";
print "Country: " . $result['country'] ."\n";
// 返回 NULL，不触发警告或错误
print "Does not exist: " . var_export($result->does_not_exist, true) . "\n";

$differentResult = $stmt->fetch(\PDO::FETCH_LAZY);
// 先前检索的 PDORow 现在指向新的检索结果
print "ID: ". $result[0] ."\n";

]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
ID: 104
Name: Chris
Country: Ukraine
Does not exist: NULL
ID: 105
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-group" annotations="chunk:false">
  <title>PDO::FETCH_GROUP (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_GROUP</constant> 返回以某一（非唯一）列作为索引的关联数组列表。此获取模式仅适用于
   <methodname>PDOStatement::fetchAll</methodname>。
  </simpara>
  <simpara>
   当与 <constant>PDO::FETCH_UNIQUE</constant> 组合使用时，两种模式会使用同一列，导致该组合失去实际作用。
  </simpara>
  <simpara>
   此获取模式应与 <constant>PDO::FETCH_ASSOC</constant>、<constant>PDO::FETCH_BOTH</constant>、<constant>PDO::FETCH_NAMED</constant>、<constant>PDO::FETCH_NUM</constant>、<constant>PDO::FETCH_COLUMN</constant>
   或 <constant>PDO::FETCH_FUNC</constant> 中的一种组合使用。
  </simpara>
  <simpara>
   若未指定上述列表中的获取模式，则当前的默认获取模式用于 <classname>PDOStatement</classname>。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                )
        )
)
]]>
   </screen>
  </informalexample>
  <simpara>
   在上述示例中需注意，每行数组中会省略第一列，该列仅作为 key 存在。若要将其包含在数组中，可重复该列，如下例所示：
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name, country FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                    [country] => Ukraine
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                    [country] => Ukraine
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                    [country] => England
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                    [country] => Germany
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                    [country] => Germany
                )
        )
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-unique" annotations="chunk:false">
  <title>PDO::FETCH_UNIQUE (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_UNIQUE</constant> uses the first column to index records,
   returning 1 record per index value. This fetch mode only works with
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   When combined with <constant>PDO::FETCH_GROUP</constant>, both modes will use
   the same column, rendering the combination of these modes useless.
  </simpara>
  <simpara>
   This fetch should be combined with one of
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant> or
   <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   If no fetch mode from the above list is given, the current default fetch mode
   for the <classname>PDOStatement</classname> will be used.
  </simpara>
  <simpara>
   When used with a column that is known to be unique (such as record ID), this
   mode provides the ability to quickly return results indexed by that value.
  </simpara>
  <note>
   <simpara>
    If the first column is not unique, values will be lost. Which value(s) are
    lost should be considered undefined.
   </simpara>
  </note>
  <caution>
   <simpara>
    Filtering records should be done in SQL where possible. The database will
    use indexes to optimize this process and return only the required records.
    Selecting more records than required from the database may significantly
    increase memory usage and query time for larger result sets.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
  <simpara>
   在上述示例中需注意，每行数组中会省略第一列，该列仅作为 key 存在。若要将其包含在数组中，可重复该列，如下例所示：
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [userid] => 104
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [userid] => 105
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [userid] => 107
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
 </section>

</section>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
