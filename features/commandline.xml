<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 8e732e84a1425cf0ab3a5b0da8fe113c7a6da85e Maintainer: HonestQiao Status: ready -->
<!-- Reviewed: Haohappy  Maintainer: HonestQiao -->
<!-- CREDITS: HonestQiao, Haohappy, Luffy -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>PHP 的命令行模式</title>

 <!--Introduction: {{{-->
 <section xml:id="features.commandline.introduction">
 <para>
  &cli.sapi; 模块主要用作 PHP 的开发外壳应用。&cli.sapi; 和其它
  <acronym>SAPI</acronym>
  模块相比有很多的不同之处，我们将在本章中详细阐述。值得一提的是，尽管 &cli;
  和 <literal>CGI</literal> 有很多共同的行为，但它们是不同的 <acronym>SAPI</acronym>。
 </para>

 <para>
  &cli.sapi; 模块会通过默认的 <option
  role="configure">--enable-cli</option> 参数设置启用，
  也可以在运行 <command>./configure</command> 时用参数
  <option role="configure">--disable-cli</option> 来屏蔽。
 </para>

 <para>
  &cli;/<acronym>CGI</acronym> 二进制执行文件的文件名、位置和是否存在会根据
  PHP 在系统上的安装而不同。在默认情况下，当运行
  <command>make</command> 时，CGI 和 &cli; 都会被编译并且分别放置在
  PHP 源文件目录的 <filename>sapi/cgi/php-cgi</filename> 和
  <filename>sapi/cli/php</filename> 下。可以注意到两个文件都被命名为了
  php。在 <command>make install</command>
  的过程中会发生什么取决于配置行。如果在配置的时候选择了一个
  <acronym>SAPI</acronym>  模块，如 apxs，或者使用了
  <option role="configure">--disable-cgi</option> 参数，则在
  <command>make install</command> 的过程中，&cli; 将被拷贝到
  <filename>{PREFIX}/bin/php</filename>，除非 <acronym>CGI</acronym>
  已经被放置在了那个位置。因此，例如，如果在配置行中有
  <option role="configure">--with--apxs</option>，则在
  <literal>make install</literal> 的过程中，&cli; 将被拷贝到
  <literal>{PREFIX}/bin/php</literal>。如果希望覆盖 <acronym>CGI</acronym>
  执行文件的安装，请在 <command>make install</command>
  之后运行 <command>make install-cli</command>。或者，也可以在配置行中加上
  <option role="configure">--disable-cgi</option> 参数。
 </para>

 <note>
  <para>
   由于 <option role="configure">--enable-cli</option> 和
   <option role="configure">--enable-cgi</option>
   同时默认有效，因此，不必再配置行中加上
   <option role="configure">--enable-cli</option> 来使得 &cli; 在
   <command>make install</command> 过程中被拷贝到
   <filename>{PREFIX}/bin/php</filename>。
  </para>
 </note>

 <para>
  在 Windows 发行包中，&cli; 在主目录中的二进制文件名为
  <filename>php.exe</filename>。<acronym>CGI</acronym> 版本的文件名为
  <filename>php-cli.exe</filename>。
  如果 PHP 配置使用了
  <option role="configure">--enable-cli-win32</option>，还会有一个额外的 <filename>
  php-win.exe</filename> 随包发布。
  它相当于 &cli; 版本，但是 php-win
  不输出任何内容，便不提供控制台（不会弹出“DOS 窗口”）。
 </para>

 <note>
  <title>如何得知自己使用的是哪个 SAPI？</title>
  <para>
   在命令行下，运行 <command>php -v</command> 便能得知该
   <filename>php</filename> 是 <acronym>CGI</acronym> 还是 &cli;。请参考函数
   <function>php_sapi_name</function> 以及常量 <constant>PHP_SAPI</constant>。
  </para>
 </note>

 <note>
  <para>
   在命令行中键入
   <command>man php</command> 可以查看 Unix <literal>man</literal> 手册页面。
  </para>
 </note>
</section>
 <!--}}}-->

 <!--Differences: {{{-->
<section xml:id="features.commandline.differences">
<title>和其它 <acronym>SAPI</acronym> 模块的区别</title>

 <para>
  以下为 &cli; <acronym>SAPI</acronym> 和其它 <acronym>SAPI</acronym> 模块相比的显著区别：
  <itemizedlist>
   <listitem>
    <para>
     与 <acronym>CGI</acronym> <acronym>SAPI</acronym> 不同，其输出没有任何头信息。
    </para>
    <para>
     尽管 <acronym>CGI</acronym> <acronym>SAPI</acronym> 提供了取消 HTTP 头信息的方法，但在
     &cli.sapi; 中并不存在类似的方法以开启 HTTP 头信息的输出。
    </para>
    <para>
     &cli; 默认以安静模式开始，但为了保证兼容性，<option>-q</option> 和
     <option>--no-header</option> 参数为了向后兼容仍然保留，使得可以使用旧的 <acronym>CGI</acronym> 脚本。
    </para>
    <para>
     在运行时，不会把工作目录改为脚本的当前目录（可以使用
     <option>-C</option> 和 <option>--no-chdir</option> 参数来兼容 CGI 模式）。
    </para>
    <para>
     出错时输出纯文本的错误信息（非 <acronym>HTML</acronym> 格式）。
    </para>
   </listitem>

   <listitem>
    <para>
     &cli.sapi; 强制覆盖了 &php.ini;
     中的某些设置，因为这些设置在外壳环境下是没有意义的。
    </para>
    <para>
     <table>
      <title>覆盖 &php.ini; 设置选项</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>设置选项</entry>
         <entry>&cli; <acronym>SAPI</acronym> 默认值</entry>
         <entry>备注</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          无意义的 <acronym>HTML</acronym>
          标记符会使得出错信息很凌乱，所以在外壳下阅读报错信息是十分困难的。因此将该选项的默认值改为 &false;。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          在命令行模式下，所有来自 <link linkend="function.print"><literal>print</literal></link> 和
          <link linkend="function.echo"><literal>echo</literal></link> 的输出将被立即写到输出端，而不作任何地缓冲操作。如果希望延缓或控制标准输出，仍然可以使用
          <link linkend="ref.outcontrol">output buffering</link> 设置项。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0（无限值）</entry>
         <entry>
          鉴于在外壳环境下使用 PHP 的无穷的可能性，最大运行时间被设置为了无限值。为
          web 开发的应用程序可能只需运行几秒钟时间，而外壳应用程序的运行时间可能会长的多。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
         由于该设置为 &true;，将总是可以在 &cli; <acronym>SAPI</acronym>
         中访问到 <emphasis>argc</emphasis>（传送给应用程序参数的个数）和
         <emphasis>argv</emphasis>（包含有实际参数的数组）。
         </para>
         <para>
          在使用 &cli; <acronym>SAPI</acronym> 时，PHP 变量
          <literal>$argc</literal> 和 <literal>$argv</literal>
          已被注册并且设定了对应的值。随时可以通过
          <varname>$_SERVER</varname> 数组
          来访问它们，例如：<varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.output-buffering">output_buffering</link></entry>
         <entry>&false;</entry>
         <entry>
          <para>
           虽然 &php.ini; 设置已经硬编码为 &false;，
           <link linkend="book.outcontrol">输出缓冲控制</link>函数仍然有效。
          </para>
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-input-time">max_input_time</link></entry>
         <entry>&false;</entry>
         <entry>
          <para>
           PHP &cli; 不支持 GET、POST、文件上传。
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      这些设置无法在设置文件 &php.ini;
      或任何指定的其它文件中被初始化为其它值。这些默认值被限制在所有其它的设置文件被解析后改变。
      不过，它们的值可以在程序运行的过程中被改变
      （尽管对于该运行过程来说，这些设置项是没有意义的，例如 <link linkend="ini.register-argc-argv">register_argc_argv</link>）。
     </para>
    </note>
    <note>
     <para>
      推荐命令行脚本设置
      <link linkend="ini.ignore-user-abort">ignore_user_abort</link>。
      更多信息参见 <function>ignore_user_abort</function>。
     </para>
    </note>
   </listitem>

   <listitem>
    <para>
     为了减轻外壳环境下的工作，我们为 <link linkend="features.commandline.io-streams">I/O 流
    </link>定义了一系列常量。
    </para>
   </listitem>

   <listitem>
    <para>
     &cli.sapi;
     <emphasis role="strong">不会</emphasis>将当前目录改为已运行的脚本所在的目录。
    </para>
    <para>
     以下范例显示了本模块与 <acronym>CGI</acronym>
     <acronym>SAPI</acronym> 模块之间的不同：
     <programlisting role="php">
<![CDATA[
<?php
// 名为 test.php 的简单测试程序
echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     在使用 <literal>CGI</literal> 版本时，其输出为
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
    </para>
    <para>
     明显可以看到 PHP 将当前目录改成了刚刚运行过的脚本所在的目录。
    </para>
    <para>
     使用 &cli.sapi; 模式，得到：
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp
]]>
     </screen>
     这使得在利用 PHP 编写外壳工具时获得了很大的便利。
    </para>
    <note>
     <para>
      可以在命令行运行时给该 <acronym>CGI</acronym> <acronym>SAPI</acronym> 加上
      <option>-C</option> 参数，使其支持 &cli.sapi; 的功能。
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
</section>
 <!--}}}-->

 <!--Options: {{{-->
<section xml:id="features.commandline.options">

<title>命令行模式的选项参数</title>
<titleabbrev>Options</titleabbrev>

 <para>
  以下是 PHP 二进制文件提供的命令行模式的选项参数，随时可以运行带
  <option>-h</option> 参数的 PHP 命令来查询这些参数。
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
   php [options] -r <code> [--] [args...]
   php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
   php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
   php [options] -- [args...]
   php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S <addr>:<port> Run with built-in web server.
  -t <docroot>     Specify document root <docroot> for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --rz <name>      Show information about Zend extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
  </screen>
 </para>

<para>
 <table>
  <title>命令行选项</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>选项名称</entry>
     <entry>长名称</entry>
     <entry>说明</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>-a</entry>
     <entry>--interactive</entry>
     <entry>
      <para>
       交互式运行 PHP。For more information, see the <link
       linkend="features.commandline.interactive">Interactive shell</link>
       section.
      </para>
     </entry>
    </row>
    <row>
     <entry>-b</entry>
     <entry>--bindpath</entry>
     <entry>
      <para>
       Bind Path for external FASTCGI Server mode (<acronym>CGI</acronym>
       only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-C</entry>
     <entry>--no-chdir</entry>
     <entry>
      <para>
       Do not chdir to the script's directory (<acronym>CGI</acronym> only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-q</entry>
     <entry>--no-header</entry>
     <entry>
      <para>
       Quiet-mode. Suppress <acronym>HTTP</acronym> header output
       (<acronym>CGI</acronym> only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-T</entry>
     <entry>--timing</entry>
     <entry>
      <para>
       Measure execution time of script repeated <varname>count</varname>
       times (<acronym>CGI</acronym> only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-c</entry>
     <entry>--php-ini</entry>
     <entry>
      <para>
       用该参数，可以指定一个放置 &php.ini;
       文件的目录，或者直接指定一个自定义的 <literal>INI</literal>
       文件（其文件名可以不是 &php.ini;），例如：
      </para>
      <para><informalexample>
       <screen>
        <![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
       </screen>
      </informalexample></para>
      <para>
       如果不指定此选项，&php.ini; 将在<link
       linkend="configuration.file">默认位置</link> 搜索。
      </para>
     </entry>
    </row>
    <row>
     <entry>-n</entry>
     <entry>--no-php-ini</entry>
     <entry>
      <para>
       完全忽略 &php.ini;。
      </para>
     </entry>
    </row>
    <row>
     <entry>-d</entry>
     <entry>--define</entry>
     <entry>
      <para>
       用该参数可以自行设置任何可以在 &php.ini;
       文件中设置的配置选项的值，其语法为：
       <screen>
        <![CDATA[
 -d configuration_directive[=value]
 ]]>
       </screen>
      </para>
      <para><example>
       <screen>
        <![CDATA[
# 取值部分被省略，将会把配置选项设为 "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# 取值部分为空白，将会把配置选项设为 ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# 配置选项将被设置成为任何 '=' 字符之后的值
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-e</entry>
     <entry>--profile-info</entry>
     <entry>
      <para>
       激活扩展信息模式，被用于调试／测试。
      </para>
     </entry>
    </row>
    <row>
     <entry>-f</entry>
     <entry>--file</entry>
     <entry>
      <para>
       解析并运行 <option>-f</option>
       选项给定的文件名。该参数为可选参数，可以省略，仅指明需要运行的文件名即可。
      </para>
      <note>
       <para>
        To pass arguments to a script, the first argument must be
        <literal>--</literal>, otherwise PHP will interpret them as PHP
        options.
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-h and -?</entry>
     <entry>--help and --usage</entry>
     <entry>
      使用该参数，可以得到完整的命令行参数的列表及这些参数作用的简单描述。
     </entry>
    </row>
    <row>
     <entry>-i</entry>
     <entry>--info</entry>
     <entry>
      该命令行参数会调用 <function>phpinfo</function>
      函数并显示出结果。如果 PHP 没有正常工作，建议执行
      <command>php -i</command>
      命令来查看在信息表格之前或者对应的地方是否有任何错误信息输出。请注意当使用
      <acronym>CGI</acronym> 摸索时，输出的内容为 <acronym>HTML</acronym>
      格式，因此输出的信息篇幅较大。
     </entry>
    </row>
    <row>
     <entry>-l</entry>
     <entry>--syntax-check</entry>
     <entry>
      <para>
       该参数提供了对指定 PHP
       代码进行语法检查的方便的方法。如果成功，则向标准输出写入
       <literal>No syntax errors detected in &lt;filename&gt;</literal>
       字符串，并且外壳返回值为
       <literal>0</literal>。如果失败，则输出
       <literal>Errors parsing
        &lt;filename&gt;</literal>
       以及内部解析器错误信息到标准输出，同时外壳返回值将别设置为
       <literal>-1</literal>。
      </para>
      <para>
       该参数将无法检查致命错误（如未定义函数），如果也希望检测致命错误，请使用
       <option>-f</option> 参数。
      </para>
      <note>
       <para>
        该参数不能和 <option>-r</option> 一同使用。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-m</entry>
     <entry>--modules</entry>
     <entry>
      <para><example>
       <title>使用该参数，PHP 将打印出内置以及已加载的 PHP 及 Zend 模块：</title>
       <screen>
        <![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-r</entry>
     <entry>--run</entry>
     <entry>
      <para>
       使用该参数可以在命令行内运行单行 PHP
       代码。<emphasis role="strong">无需</emphasis>加上 PHP
       的起始和结束标识符（<literal>&lt;?php</literal> 和
       <literal>?&gt;</literal>），否则将会导致语法解析错误。
      </para>
      <note>
       <para>
        使用这种形式的 PHP 时，应注意避免和外壳环境进行的命令行参数替换相冲突。
       </para>
       <example>
        <title>显示双引号语法解析错误的范例</title>
        <screen>
         <![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
        </screen>
       </example>
       <para>
        这里的问题在于即使使用了双引号
        <literal>"</literal>，sh/bash 仍然实行了参数替换。由于
        <varname>$foo</varname>
        没有被定义，被替换后它所在的位置变成了空字符，因此在运行时，实际被
        PHP 读取的代码为：
       </para>
       <informalexample>
        <screen>
         <![CDATA[
$ php -r " = get_defined_constants();"
]]>
        </screen>
       </informalexample>

       <para>
        正确的方法是使用单引号
        <literal>'</literal>。在用单引号引用的字符串中，变量不会被
        sh/bash 还原成其原值。
       </para>
       <example>
        <title>Using single quotes to prevent the shell's variable
         substitution</title>
        <screen>
         <![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
        </screen>
       </example>
       <para>
        如果使用的外壳不是 sh/bash，可能会碰到更多问题。请将碰到的 Bug
        向 <link xlink:href="&url.php.bugs;">&url.php.bugs;</link>
        报告。注意，当试图将 shell 变量用到代码中或者使用反斜线时仍然很容易碰到问题。
       </para>
      </note>
      <note>
       <para>
        <option>-r</option> 在 &cli.sapi;
        中有效，在 <emphasis>CGI</emphasis> <acronym>SAPI</acronym> 中无效。
       </para>
      </note>
      <note>
       <para>
        此选项只用于非常基本的用途。因此一些配置指令（例如 <link
        linkend="ini.auto-prepend-file">auto_prepend_file</link> 和 <link
        linkend="ini.auto-append-file">auto_append_file</link>）在此模式下被忽略。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-B</entry>
     <entry>--process-begin</entry>
     <entry>
      <para>
       在处理 stdin 之前先执行 PHP 代码。
      </para>
     </entry>
    </row>
    <row>
     <entry>-R</entry>
     <entry>--process-code</entry>
     <entry>
      <para>
       对每个输入行都执行 PHP 代码。
      </para>
      <para>
       此模式下有两个特殊变量：<varname>$argn</varname>
       和 <varname>$argi</varname>。<varname>$argn</varname>
       包含 PHP 当前处理的行内容，而
       <varname>$argi</varname> 则包含该行号。
      </para>
     </entry>
    </row>
    <row>
     <entry>-F</entry>
     <entry>--process-file</entry>
     <entry>
      <para>
       对每个输入行都执行 PHP 文件。
      </para>
     </entry>
    </row>
    <row>
     <entry>-E</entry>
     <entry>--process-end</entry>
     <entry>
      <para>
       在处理完输入后执行的 PHP 代码。
      </para>
      <para><example>
       <title>
        使用 <option>-B</option>，<option>-R</option> 和
        <option>-E</option> 选项来计算一个项目总行数的例子。
       </title>
       <screen>
        <![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-S</entry>
     <entry>--server</entry>
     <entry>
      <para>
       Starts <link linkend="features.commandline.webserver">built-in web
       server</link>.
      </para>
     </entry>
    </row>
    <row>
     <entry>-t</entry>
     <entry>--docroot</entry>
     <entry>
      Specifies document root for <link
      linkend="features.commandline.webserver">built-in web server</link>.
     </entry>
    </row>
    <row>
     <entry>-s</entry>
     <entry>--syntax-highlight and --syntax-highlighting</entry>
     <entry>
      <para>
       显示有语法高亮色彩的源代码。
      </para>
      <para>
       该参数使用内建机制来解析文件并为其生成一个 HTML
       高亮版本并将结果写到标准输出。请注意该过程所做的只是生成了一个
       <literal>&lt;code&gt; [...] &lt;/code&gt;</literal> 的
       HTML 标记的块，并不包含任何的 HTML 头。
      </para>
      <note>
       <para>
        该选项不能和 <option>-r</option> 参数同时使用。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-v</entry>
     <entry>--version</entry>
     <entry>
      <para><example>
       <title>
        使用 <option>-v</option> 将 PHP、<acronym>SAPI</acronym> 名称和 Zend 的版本信息写入标准输出。
       </title>
       <screen>
        <![CDATA[
$ php -v
PHP 5.3.1 (cli) (built: Dec 11 2009 19:55:07)
Copyright (c) 1997-2009 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2009 Zend Technologies
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-w</entry>
     <entry>--strip</entry>
     <entry>
      <para>
       显示除去了注释和多余空白的源代码。
      </para>
      <note>
       <para>
        该选项不能和 <option>-r</option> 参数同时使用。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-z</entry>
     <entry>--zend-extension</entry>
     <entry>
      <para>
       加载 Zend 扩展库。如果仅给定一个文件名，PHP
       将试图从当前系统扩展库的默认路径（在 Linux
       系统下，该路径通常由 <filename>/etc/ld.so.conf</filename>
       指定）加载该扩展库。如果用一个绝对路径指定文件名，则不会使用系统的扩展库默认路径。如果用相对路径指定的文件名，则
       PHP 仅试图在当前目录的相对目录加载扩展库。
      </para>
     </entry>
    </row>
    <row>
     <entry></entry>
     <entry>--ini</entry>
     <entry>
      <para>
       Show configuration file names and scanned directories.
       <example>
        <title><literal>--ini</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--rf</entry>
     <entry>--rfunction</entry>
     <entry>
      <para>
       Show information about the given function or class method (e.g.
       number and name of the parameters).
      </para>
      <para>
       This option is only available if PHP was compiled with
       <link linkend="book.reflection">Reflection</link> support.
      </para>
      <para>
       <example>
        <title>basic <literal>--rf</literal> usage</title>
        <programlisting role="shell">
         <![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--rc</entry>
     <entry>--rclass</entry>
     <entry>
      <para>
       Show information about the given class (list of constants, properties
       and methods).
      </para>
      <para>
       This option is only available if PHP was compiled with
       <link linkend="book.reflection">Reflection</link> support.
      </para>
      <para>
       <example>
        <title><literal>--rc</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--re</entry>
     <entry>--rextension</entry>
     <entry>
      <para>
       Show information about the given extension (list of &php.ini; options,
       defined functions, constants and classes).
      </para>
      <para>
       This option is only available if PHP was compiled with
       <link linkend="book.reflection">Reflection</link> support.
      </para>
      <para>
       <example>
        <title><literal>--re</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--rz</entry>
     <entry>--rzendextension</entry>
     <entry>
      <para>
       Show the configuration information for the given Zend extension (the
       same information that is returned by <function>phpinfo</function>).
      </para>
     </entry>
    </row>
    <row>
     <entry>--ri</entry>
     <entry>--rextinfo</entry>
     <entry>
      <para>
       Show the configuration information for the given extension (the same
       information that is returned by <function>phpinfo</function>).
       The core configuration information
       is available using "main" as extension name.
      </para>
      <para>
       <example>
        <title><literal>--ri</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2009.20
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.930972 => 59.930972
date.default_longitude => 10.776699 => 10.776699
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</para>

<note>
 <para>
  Options <literal>-rBRFEH</literal>, <literal>--ini</literal> and
  <literal>--r[fcezi]</literal> are available only in &cli;.
 </para>
</note>
</section>
 <!--}}}-->

 <!--Usage: {{{-->
<section xml:id="features.commandline.usage">
<title>Executing PHP files</title>
<titleabbrev>Usage</titleabbrev>

 <para>
  &cli.sapi; 模块有以下三种不同的方法来获取要运行的 PHP 代码：
  <orderedlist>
   <listitem>
    <para>
     让 PHP 运行指定文件。
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
    </para>
    <para>
     以上两种方法（使用或不使用 <option>-f</option> 参数）都能够运行给定的
     <filename>my_script.php</filename> 文件。可以选择任何文件来运行，指定的
     PHP 脚本并非必须要以 <literal>.php</literal>
     为扩展名，它们可以有任意的文件名和扩展名。
    </para>
    <note>
     <para>
      If arguments need to be passed to the script when using
      <option>-f</option>, the first argument must be <literal>--</literal>.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     在命令行直接运行 PHP 代码。
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
    </para>
    <para>
     在使用这种方法时，请注意外壳变量的替代及引号的使用。
    </para>
    <note>
     <para>
      请仔细阅读以上范例，在运行代码时没有开始和结束的标记符！加上
      <option>-r</option> 参数后，这些标记符是不需要的，加上它们会导致语法错误。
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     通过标准输入（<literal>stdin</literal>）提供需要运行的 PHP 代码。
    </para>
    <para>
     以上用法提供了非常强大的功能，使得可以如下范例所示，动态地生成
     PHP 代码并通过命令行运行这些代码：
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  以上三种运行代码的方法不能同时使用。
 </para>

 <para>
  和所有的外壳应用程序一样，PHP 的二进制文件及其运行的 PHP 脚本能够接受一系列的参数。PHP
  没有限制传送给脚本程序的参数的个数（外壳程序对命令行的字符数有限制，但通常都不会超过该限制）。传递给脚本的参数可在全局变量
  <varname>$argv</varname> 中获取。该数组中下标为零的成员 <varname>$argv[0]</varname> 为脚本的名称（当
  PHP 代码来自标准输入获直接用 <option>-r</option>
  参数以命令行方式运行时，该名称为“<literal>-</literal>”）。The same is true if the code is
  executed via a pipe from <literal>STDIN</literal>.
 </para>

 <para>
 另外，全局变量
 <varname>$argc</varname> 存有 <varname>$argv</varname>
 数组中成员变量的个数（而<emphasis role="strong">非</emphasis>传送给脚本程序的参数的个数）。
 </para>

 <para>
  只要传送给脚本的参数不是以 <literal>-</literal>
  符号开头，就无需过多的注意什么。向脚本传送以
  <literal>-</literal> 开头的参数会导致错误，因为 PHP
  会认为应该由它自身来处理这些参数。可以用参数列表分隔符
  <literal>--</literal> 来解决这个问题。在 PHP
  解析完参数后，该符号后所有的参数将会被原样传送给脚本程序。
 </para>

<informalexample>
  <screen>
<![CDATA[
# 以下命令将不会运行 PHP 代码，而只显示 PHP 命令行模式的使用说明：
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# 以下命令将会把“-h”参数传送给脚本程序，PHP 不会显示命令行模式的使用说明：
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
 </screen>
</informalexample>

 <para>
  除此之外，还有另一个方法将 PHP 用于外壳脚本。可以在写一个脚本，并在第一行以
  <literal>#!/usr/bin/php</literal> 开头，在其后加上以 PHP
  开始和结尾标记符包含的正常的 PHP
  代码，然后为该文件设置正确的运行属性（例如：<command>chmod +x test</command>）。
  该方法可以使得该文件能够像外壳脚本或 PERL 脚本一样被直接执行。
 </para>

<example>
 <title>Execute PHP script as shell script</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
 <para>
  假设改文件名为 <filename>test</filename> 并被放置在当前目录下，可以做如下操作：
 </para>
  <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
</example>

 <para>
  正如所看到的，在向该脚本传送以 <literal>-</literal> 开头的参数时，脚本仍然能够正常运行。
 </para>

 <para>
  PHP 的命令行模式能使得 PHP 脚本能完全独立于 web 服务器单独运行。如果使用
  Unix 系统，需要在 PHP
  脚本的最前面加上一行特殊的代码，使得它能够被执行，这样系统就能知道用哪个程序去运行该脚本。在
  Windows 平台下可以将 <filename>php.exe</filename> 和 <literal>.php</literal>
  文件的双击属性相关联，也可以编写一个批处理文件来用 PHP
  执行脚本。为 Unix 系统增加的第一行代码不会影响该脚本在
  Windows 下的运行，因此也可以用该方法编写跨平台的脚本程序。以下是一个简单的
  PHP 命令行程序的范例。
 </para>

 <para>
  <example>
   <title>试图以命令行方式运行的 PHP 脚本（script.php）</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
 </para>

 <para>
  在以上脚本中，用第一行特殊的代码来指明该文件应该由 PHP
  来执行。在这里使用 &cli; 的版本，因此不会有 HTTP 头信息输出。
 </para>

 <para>
  以上程序中检查了参数的个数是大于 1 个还是小于 1
  个。此外如果参数是 <option>--help</option>，<option>-help</option>，<option>-h</option>
  或 <option>-?</option>
  时，打印出帮助信息，并同时用 <varname>$argv[0]</varname> 动态输出脚本的名称。如果还收到了其它参数，将其显示出来。
 </para>

 <para>
  如果希望在 Unix 下运行以上脚本，需要使其属性为可执行文件，然后简单的运行
  <command>script.php echothis</command> 或 <command>script.php -h</command>。在
  Windows 下，可以为此编写一个批处理文件：
 </para>

 <para>
  <example>
   <title>运行 PHP 命令行脚本的批处理文件（script.bat）</title>
   <programlisting role="shell">
<![CDATA[
@echo OFF
"C:\php\php.exe" script.php %*
]]>
   </programlisting>
  </example>
 </para>

 <para>
  假设将上述程序命名为 <filename>script.php</filename>，且
  &cli; 版的 <filename>php.exe</filename> 文件放置在
  <filename>c:\php\cli\php.exe</filename>，该批处理文件会帮助将附加的参数传给脚本程序：<command>script.bat
  echothis</command> 或 <command>script.bat -h</command>。
 </para>

 <para>
  请参阅 <link linkend="ref.readline">Readline</link>
  扩展模块的有关文档，以获取更多的函数的信息。这些函数可以帮助完善 PHP 命令行应用程序。
 </para>

 <para>
  On Windows, PHP can be configured to run without the need to
  supply the <filename>C:\php\php.exe</filename> or the <literal>.php</literal>
  extension, as described in <link linkend="install.windows.commandline">Command
  Line PHP on Microsoft Windows</link>.
 </para>

 <note>
  <para>
   On Windows it is recommended to run PHP under an actual user account.
   When running under a network service certain operations will fail, because
   "No mapping between account names and security IDs was done".
  </para>
 </note>
</section>
 <!--}}}-->


 <!--I/O Streams: {{{-->
<section xml:id="features.commandline.io-streams">
<title>Input/output streams</title>
<titleabbrev>I/O streams</titleabbrev>

<para>
 The &cli.sapi; defines a few constants for I/O streams to make programming
 for the command line a bit easier.
</para>

<para>
 <table>
  <title>CLI 专用常量</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>常量名称</entry>
     <entry>描述</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><constant>STDIN</constant></entry>
     <entry>
      <para>An already opened stream to <literal>stdin</literal>. This saves
       opening it with
       <programlisting role="php">
        <![CDATA[
<?php
$stdin = fopen('php://stdin', 'r');
?>
]]>
       </programlisting>
       If you want to read single line from <literal>stdin</literal>, you can
       use
       <programlisting role="php">
        <![CDATA[
<?php
$line = trim(fgets(STDIN)); // reads one line from STDIN
fscanf(STDIN, "%d\n", $number); // reads number from STDIN
?>
]]>
       </programlisting>
      </para></entry>
    </row>
    <row>
     <entry><constant>STDOUT</constant></entry>
     <entry><para>
      An already opened stream to <literal>stdout</literal>. This saves
      opening it with
      <programlisting role="php">
       <![CDATA[
<?php
$stdout = fopen('php://stdout', 'w');
?>
]]>
      </programlisting>
     </para></entry>
    </row>
    <row>
     <entry><constant>STDERR</constant></entry>
     <entry>
      <para>
       An already opened stream to <literal>stderr</literal>.
       This saves opening it with
       <programlisting role="php">
        <![CDATA[
<?php
$stderr = fopen('php://stderr', 'w');
?>
]]>
       </programlisting>
      </para>
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</para>

<para>
 有了以上常量，就无需自己建立指向诸如 <literal>stderr</literal>
 的流，只需简单的使用这些常量来代替流指向：
 <programlisting role="shell">
  <![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
 </programlisting>
 无需自己来关闭这些流，PHP 会在脚本结束时自动完成这些操作。
</para>

<note>
 <para>
  These constants are not available if reading the PHP script from
  <literal>stdin</literal>.
 </para>
</note>
</section>
 <!--}}}-->

 <!--Interactive shell: {{{-->
<section xml:id="features.commandline.interactive">
<title>Interactive shell</title>

<para>
 The &cli.sapi; provides an interactive shell using the
 <option>-a</option> option if PHP is compiled with the <option
 role="configure">--with-readline</option> option.
</para>

<para>
 Using the interactive shell you are able to type PHP code and have it
 executed directly.
</para>

<example>
 <title>Executing code using the interactive shell</title>
 <programlisting role="shell">
  <![CDATA[
$ php -a
Interactive shell

php > echo 5+8;
13
php > function addTwo($n)
php > {
php { return $n + 2;
php { }
php > var_dump(addtwo(2));
int(4)
php >
]]>
 </programlisting>
</example>

<para>
 The interactive shell also features tab completion for functions,
 constants, class names, variables, static method calls and class
 constants.
</para>

<example>
 <title>Tab completion</title>
 <simpara>
  Pressing the tab key twice when there are multiple possible completions
  will result in a list of these completions:
 </simpara>
 <programlisting role="shell">
  <![CDATA[
php > strp[TAB][TAB]
strpbrk   strpos    strptime
php > strp
]]>
 </programlisting>
 <simpara>
  When there is only one possible completion, pressing tab once will
  complete the rest on the same line:
 </simpara>
 <programlisting role="shell">
  <![CDATA[
php > strpt[TAB]ime(
]]>
 </programlisting>
 <simpara>
  Completion will also work for names that have been defined
  during the current interactive shell session:
 </simpara>
 <programlisting role="shell">
  <![CDATA[
php > $fooThisIsAReallyLongVariableName = 42;
php > $foo[TAB]ThisIsAReallyLongVariableName
]]>
 </programlisting>
</example>

<para>
 The interactive shell stores your history which can be accessed using the up
 and down keys. The history is saved in the
 <filename>~/.php_history</filename> file.
</para>

<para>
 The &cli.sapi; provides
 the &php.ini; settings <parameter>cli.pager</parameter> and
 <parameter>cli.prompt</parameter>. The <parameter>cli.pager</parameter>
 setting allows an external program (such as <filename>less</filename>) to
 act as a pager for the output instead of being displayed directly on the
 screen. The <parameter>cli.prompt</parameter> setting makes it possible to
 change the <literal>php &gt;</literal> prompt.
</para>

<para>
 It is also possible to set
 &php.ini; settings in the interactive shell using a shorthand notation.
</para>

<example>
 <title>Setting &php.ini; settings in the interactive shell</title>
 <simpara>
  The <parameter>cli.prompt</parameter> setting:
 </simpara>
 <programlisting role="shell">
  <![CDATA[
php > #cli.prompt=hello world :>
hello world :>
]]>
 </programlisting>
 <simpara>
  Using backticks it is possible to have PHP code executed in the prompt:
 </simpara>
 <programlisting role="shell">
  <![CDATA[
php > #cli.prompt=`echo date('H:i:s');` php >
15:49:35 php > echo 'hi';
hi
15:49:43 php > sleep(2);
15:49:45 php >
]]>
 </programlisting>
 <simpara>
  Setting the pager to <filename>less</filename>:
 </simpara>
 <programlisting role="shell">
  <![CDATA[
php > #cli.pager=less
php > phpinfo();
(output displayed in less)
php >
]]>
 </programlisting>
</example>

<para>
 The <parameter>cli.prompt</parameter> setting supports a few escape
 sequences:
 <table>
  <title><parameter>cli.prompt</parameter> escape sequences</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Sequence</entry>
     <entry>Description</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>\e</literal></entry>
     <entry>
      Used for adding colors to the prompt. An example could be
      <literal>\e[032m\v \e[031m\b \e[34m\> \e[0m</literal>
     </entry>
    </row>
    <row>
     <entry><literal>\v</literal></entry>
     <entry>The PHP version.</entry>
    </row>
    <row>
     <entry><literal>\b</literal></entry>
     <entry>
      Indicates which block PHP is in. For instance <literal>/*</literal> to
      indicate being inside a multi-line comment. The outer scope is denoted by
      <literal>php</literal>.
     </entry>
    </row>
    <row>
     <entry><literal>\&gt;</literal></entry>
     <entry>
      Indicates the prompt character. By default this is
      <literal>&gt;</literal>, but changes when the shell is inside an
      unterminated block or string. Possible characters are: <literal>' " {
      ( &gt;</literal>
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</para>

<note>
 <para>
  Files included through <link
  linkend="ini.auto-prepend-file">auto_prepend_file</link> and <link
  linkend="ini.auto-append-file">auto_append_file</link> are parsed in
  this mode but with some restrictions - e.g. functions have to be
  defined before called.
 </para>
</note>

<note>
 <para>
  <link linkend="language.oop5.autoload">Autoloading</link> is not
  available if using PHP in &cli; interactive mode.
 </para>
</note>
</section>
 <!--}}}-->

 <!--Built-in CLI Web Server: {{{-->
 <section xml:id="features.commandline.webserver">
  <title>内置Web Server</title>

  <para>
   &cli.sapi; 提供了一个内置的Web服务器。
  </para>
<para>   
   这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。
  </para>

  <para>
     URI请求会被发送到PHP所在的的工作目录（Working Directory）进行处理，除非你使用了-t参数来自定义不同的目录。
  </para>

  <para>
  
   如果请求未指定执行哪个PHP文件，则默认执行目录内的index.php 或者 index.html。如果这两个文件都不存在，服务器会返回404错误。
  </para>

  <para>  
   
   当你在命令行启动这个Web Server时，如果指定了一个PHP文件，则这个文件会作为一个“路由”脚本，意味着每次请求都会先执行这个脚本。如果这个脚本返回 &false; ，那么直接返回请求的文件（例如请求静态文件不作任何处理）。否则会把输出返回到浏览器。
  </para>

  <example>
   <title>启动Web服务器</title> 
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000
]]>
   </programlisting>
   <para>
     终端窗口会显示:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
]]>
   </screen>
   <para>   
    
    接着访问http://localhost:8000/和http://localhost:8000/myscript.html，窗口会显示：
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
]]>
   </screen>
  </example>

  <example>
   <title>启动时指定根目录</title> 
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000 -t foo/
]]>
   </programlisting>
   <para>
     终端窗口显示：
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
]]>
   </screen>
  </example>

  <example>
   <title>使用路由（Router）脚本</title> 
<para>
 
 请求图片直接显示图片，请求HTML则显示“Welcome to PHP”
</para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"]))
    return false;    // 直接返回请求的文件
else { 
    echo "<p>Welcome to PHP</p>";
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
   <para>
    
    执行之后终端显示：
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:53:19 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:53:45 2011] ::1:55801 GET /mylogo.jpg - Request read
[Thu Jul 21 10:53:52 2011] ::1:55803 GET /abc.html - Request read
[Thu Jul 21 10:53:52 2011] ::1:55804 GET /favicon.ico - Request read
]]>
   </screen>
  </example>
  <example>
   <title>Checking for CLI Web Server Use</title>
   <para>
    To reuse a framework router script during development with the CLI web server and later also with a production web server:
   </para>
   <programlisting role="php">
    <![CDATA[
<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* route static assets and return false */
}
/* go on with normal index.php operations */
?>]]>
   </programlisting>
   <programlisting role="shell">
    <![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Handling Unsupported File Types</title>
   <para>
    If you need to serve a static resource whose MIME type is not handled by the CLI web server, use:
   </para>
   <programlisting role="php">
    <![CDATA[
<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>]]>
   </programlisting>
   <programlisting role="shell">
    <![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Accessing the CLI Web Server From Remote Machines</title>
   <para>
    You can make the web server accessible on port 8000 to any interface with:
   </para>
   <programlisting role="shell">
    <![CDATA[
$ php -S 0.0.0.0:8000
]]>
   </programlisting>
   <warning>
    <para>
     The built-in Web Server should not be used on a public network.
    </para>
   </warning>
  </example>

 </section>
 <!--}}}-->

  <section xml:id="features.commandline.ini">
   <title>INI 配置</title>
   <para>
    <table>
     <title>CLI SAPI 配置选项</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>&Name;</entry>
        <entry>&Default;</entry>
        <entry>&Changeable;</entry>
        <entry>&Changelog;</entry>
       </row>
      </thead>
      <tbody xml:id="features.commandline.ini.list">
       <row>
        <entry><link linkend="ini.cli-server.color">cli_server.color</link></entry>
        <entry>"0"</entry>
        <entry>PHP_INI_ALL</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   
   &ini.descriptions.title;
   
   <para>
    <variablelist>
     <varlistentry xml:id="ini.cli-server.color">
      <term>
       <parameter>cli_server.color</parameter>
       <type>boolean</type>
      </term>
      <listitem>
       <para>        
        控制内置Web Server的终端输出有无颜色。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
