<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a2fc23851f710d7f0de3dceb23dc68ee34d17b32 Maintainer: HonestQiao Status: ready -->
<!-- Reviewed: Haohappy  Maintainer: HonestQiao -->
<!-- CREDITS: HonestQiao, Haohappy, Luffy, mowangjuanzi -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>PHP 的命令行模式</title>

 <!--Introduction: {{{-->
 <section xml:id="features.commandline.introduction">
 <para>
  &cli.sapi; 模块主要用作 PHP 的开发外壳应用。&cli.sapi; 和其它
  <acronym>SAPI</acronym>
  模块相比有很多的不同之处，我们将在本章中详细阐述。值得一提的是，尽管 &cli;
  和 <literal>CGI</literal> 有很多共同的行为，但它们是不同的 <acronym>SAPI</acronym>。
 </para>

 <para>
  &cli.sapi; 模块会通过默认的 <option
  role="configure">--enable-cli</option> 参数设置启用，
  也可以在运行 <command>./configure</command> 时用参数
  <option role="configure">--disable-cli</option> 来屏蔽。
 </para>

 <para>
  &cli;/<acronym>CGI</acronym> 二进制执行文件的文件名、位置和是否存在会根据
  PHP 在系统上的安装而不同。在默认情况下，当运行
  <command>make</command> 时，CGI 和 &cli; 都会被编译并且分别放置在
  PHP 源文件目录的 <filename>sapi/cgi/php-cgi</filename> 和
  <filename>sapi/cli/php</filename> 下。可以注意到两个文件都被命名为了
  php。在 <command>make install</command>
  的过程中会发生什么取决于配置行。如果在配置的时候选择了一个
  <acronym>SAPI</acronym>  模块，如 apxs，或者使用了
  <option role="configure">--disable-cgi</option> 参数，则在
  <command>make install</command> 的过程中，&cli; 将被拷贝到
  <filename>{PREFIX}/bin/php</filename>，除非 <acronym>CGI</acronym>
  已经被放置在了那个位置。因此，例如，如果在配置行中有
  <option role="configure">--with--apxs</option>，则在
  <literal>make install</literal> 的过程中，&cli; 将被拷贝到
  <literal>{PREFIX}/bin/php</literal>。如果希望覆盖 <acronym>CGI</acronym>
  执行文件的安装，请在 <command>make install</command>
  之后运行 <command>make install-cli</command>。或者，也可以在配置行中加上
  <option role="configure">--disable-cgi</option> 参数。
 </para>

 <note>
  <para>
   由于 <option role="configure">--enable-cli</option> 和
   <option role="configure">--enable-cgi</option>
   同时默认有效，因此，不必再配置行中加上
   <option role="configure">--enable-cli</option> 来使得 &cli; 在
   <command>make install</command> 过程中被拷贝到
   <filename>{PREFIX}/bin/php</filename>。
  </para>
 </note>

 <para>
  在 Windows 发行包中，&cli; 在主目录中的二进制文件名为
  <filename>php.exe</filename>。<acronym>CGI</acronym> 版本的文件名为
  <filename>php-cgi.exe</filename>。
  如果 PHP 配置使用了
  <option role="configure">--enable-cli-win32</option>，还会有一个额外的 <filename>
  php-win.exe</filename> 随包发布。
  它相当于 &cli; 版本，但是 php-win
  不输出任何内容，便不提供控制台（不会弹出“DOS 窗口”）。
 </para>

 <note>
  <title>如何得知自己使用的是哪个 SAPI？</title>
  <para>
   在命令行下，运行 <command>php -v</command> 便能得知该
   <filename>php</filename> 是 <acronym>CGI</acronym> 还是 &cli;。请参考函数
   <function>php_sapi_name</function> 以及常量 <constant>PHP_SAPI</constant>。
  </para>
 </note>

 <note>
  <para>
   在命令行中键入
   <command>man php</command> 可以查看 Unix <literal>man</literal> 手册页面。
  </para>
 </note>
</section>
 <!--}}}-->

 <!--Differences: {{{-->
<section xml:id="features.commandline.differences">
<title>和其它 <acronym>SAPI</acronym> 模块的区别</title>

 <para>
  以下为 &cli; <acronym>SAPI</acronym> 和其它 <acronym>SAPI</acronym> 模块相比的显著区别：
  <itemizedlist>
   <listitem>
    <para>
     与 <acronym>CGI</acronym> <acronym>SAPI</acronym> 不同，其输出没有任何头信息。
    </para>
    <para>
     尽管 <acronym>CGI</acronym> <acronym>SAPI</acronym> 提供了取消 HTTP 头信息的方法，但在
     &cli.sapi; 中并不存在类似的方法以开启 HTTP 头信息的输出。
    </para>
    <para>
     &cli; 默认以安静模式开始，但为了保证兼容性，<option>-q</option> 和
     <option>--no-header</option> 参数为了向后兼容仍然保留，使得可以使用旧的 <acronym>CGI</acronym> 脚本。
    </para>
    <para>
     在运行时，不会把工作目录改为脚本的当前目录（可以使用
     <option>-C</option> 和 <option>--no-chdir</option> 参数来兼容 CGI 模式）。
    </para>
    <para>
     出错时输出纯文本的错误信息（非 <acronym>HTML</acronym> 格式）。
    </para>
   </listitem>

   <listitem>
    <para>
     &cli.sapi; 强制覆盖了 &php.ini;
     中的某些设置，因为这些设置在外壳环境下是没有意义的。
    </para>
    <para>
     <table>
      <title>覆盖 &php.ini; 设置选项</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>设置选项</entry>
         <entry>&cli; <acronym>SAPI</acronym> 默认值</entry>
         <entry>备注</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          无意义的 <acronym>HTML</acronym>
          标记符会使得出错信息很凌乱，所以在外壳下阅读报错信息是十分困难的。因此将该选项的默认值改为 &false;。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          在命令行模式下，所有来自 <link linkend="function.print"><literal>print</literal></link> 和
          <link linkend="function.echo"><literal>echo</literal></link> 的输出将被立即写到输出端，而不作任何地缓冲操作。如果希望延缓或控制标准输出，仍然可以使用
          <link linkend="ref.outcontrol">output buffering</link> 设置项。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0（无限值）</entry>
         <entry>
          鉴于在外壳环境下使用 PHP 的无穷的可能性，最大运行时间被设置为了无限值。为
          web 开发的应用程序可能只需运行几秒钟时间，而外壳应用程序的运行时间可能会长的多。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
         由于该设置为 &true;，将总是可以在 &cli; <acronym>SAPI</acronym>
         中访问到 <emphasis>argc</emphasis>（传送给应用程序参数的个数）和
         <emphasis>argv</emphasis>（包含有实际参数的数组）。
         </para>
         <para>
          在使用 &cli; <acronym>SAPI</acronym> 时，PHP 变量
          <literal>$argc</literal> 和 <literal>$argv</literal>
          已被注册并且设定了对应的值。随时可以通过
          <varname>$_SERVER</varname> 数组
          来访问它们，例如：<varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.output-buffering">output_buffering</link></entry>
         <entry>&false;</entry>
         <entry>
          <para>
           虽然 &php.ini; 设置已经硬编码为 &false;，
           <link linkend="book.outcontrol">输出缓冲控制</link>函数仍然有效。
          </para>
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-input-time">max_input_time</link></entry>
         <entry>&false;</entry>
         <entry>
          <para>
           PHP &cli; 不支持 GET、POST、文件上传。
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      这些设置无法在设置文件 &php.ini;
      或任何指定的其它文件中被初始化为其它值。这些默认值被限制在所有其它的设置文件被解析后改变。
      不过，它们的值可以在程序运行的过程中被改变
      （尽管对于该运行过程来说，这些设置项是没有意义的，例如 <link linkend="ini.register-argc-argv">register_argc_argv</link>）。
     </para>
    </note>
    <note>
     <para>
      推荐命令行脚本设置
      <link linkend="ini.ignore-user-abort">ignore_user_abort</link>。
      更多信息参见 <function>ignore_user_abort</function>。
     </para>
    </note>
   </listitem>

   <listitem>
    <para>
     为了减轻外壳环境下的工作，我们为 <link linkend="features.commandline.io-streams">I/O 流
    </link>定义了一系列常量。
    </para>
   </listitem>

   <listitem>
    <para>
     &cli.sapi;
     <emphasis role="strong">不会</emphasis>将当前目录改为已运行的脚本所在的目录。
    </para>
    <para>
     以下范例显示了本模块与 <acronym>CGI</acronym>
     <acronym>SAPI</acronym> 模块之间的不同：
     <programlisting role="php">
<![CDATA[
<?php
// 名为 test.php 的简单测试程序
echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     在使用 <literal>CGI</literal> 版本时，其输出为
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
    </para>
    <para>
     明显可以看到 PHP 将当前目录改成了刚刚运行过的脚本所在的目录。
    </para>
    <para>
     使用 &cli.sapi; 模式，得到：
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp
]]>
     </screen>
     这使得在利用 PHP 编写外壳工具时获得了很大的便利。
    </para>
    <note>
     <para>
      可以在命令行运行时给该 <acronym>CGI</acronym> <acronym>SAPI</acronym> 加上
      <option>-C</option> 参数，使其支持 &cli.sapi; 的功能。
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
</section>
 <!--}}}-->

 <!--Options: {{{-->
<section xml:id="features.commandline.options">

<title>命令行模式的选项参数</title>
<titleabbrev>Options</titleabbrev>

 <para>
  以下是 PHP 二进制文件提供的命令行模式的选项参数，随时可以运行带
  <option>-h</option> 参数的 PHP 命令来查询这些参数。
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
   php [options] -r <code> [--] [args...]
   php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
   php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
   php [options] -- [args...]
   php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S <addr>:<port> Run with built-in web server.
  -t <docroot>     Specify document root <docroot> for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --rz <name>      Show information about Zend extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
  </screen>
 </para>

<para>
 <table>
  <title>命令行选项</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>选项名称</entry>
     <entry>长名称</entry>
     <entry>说明</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>-a</entry>
     <entry>--interactive</entry>
     <entry>
      <para>
       交互式运行 PHP。For more information, see the <link
       linkend="features.commandline.interactive">Interactive shell</link>
       section.
      </para>
     </entry>
    </row>
    <row>
     <entry>-b</entry>
     <entry>--bindpath</entry>
     <entry>
      <para>
       Bind Path for external FASTCGI Server mode (<acronym>CGI</acronym>
       only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-C</entry>
     <entry>--no-chdir</entry>
     <entry>
      <para>
       Do not chdir to the script's directory (<acronym>CGI</acronym> only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-q</entry>
     <entry>--no-header</entry>
     <entry>
      <para>
       Quiet-mode. Suppress <acronym>HTTP</acronym> header output
       (<acronym>CGI</acronym> only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-T</entry>
     <entry>--timing</entry>
     <entry>
      <para>
       Measure execution time of script repeated <varname>count</varname>
       times (<acronym>CGI</acronym> only).
      </para>
     </entry>
    </row>
    <row>
     <entry>-c</entry>
     <entry>--php-ini</entry>
     <entry>
      <para>
       用该参数，可以指定一个放置 &php.ini;
       文件的目录，或者直接指定一个自定义的 <literal>INI</literal>
       文件（其文件名可以不是 &php.ini;），例如：
      </para>
      <para><informalexample>
       <screen>
        <![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
       </screen>
      </informalexample></para>
      <para>
       如果不指定此选项，&php.ini; 将在<link
       linkend="configuration.file">默认位置</link> 搜索。
      </para>
     </entry>
    </row>
    <row>
     <entry>-n</entry>
     <entry>--no-php-ini</entry>
     <entry>
      <para>
       完全忽略 &php.ini;。
      </para>
     </entry>
    </row>
    <row>
     <entry>-d</entry>
     <entry>--define</entry>
     <entry>
      <para>
       用该参数可以自行设置任何可以在 &php.ini;
       文件中设置的配置选项的值，其语法为：
       <screen>
        <![CDATA[
 -d configuration_directive[=value]
 ]]>
       </screen>
      </para>
      <para><example>
       <screen>
        <![CDATA[
# 取值部分被省略，将会把配置选项设为 "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# 取值部分为空白，将会把配置选项设为 ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# 配置选项将被设置成为任何 '=' 字符之后的值
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-e</entry>
     <entry>--profile-info</entry>
     <entry>
      <para>
       激活扩展信息模式，被用于调试／测试。
      </para>
     </entry>
    </row>
    <row>
     <entry>-f</entry>
     <entry>--file</entry>
     <entry>
      <para>
       解析并运行 <option>-f</option>
       选项给定的文件名。该参数为可选参数，可以省略，仅指明需要运行的文件名即可。
      </para>
      <note>
       <para>
        To pass arguments to a script, the first argument must be
        <literal>--</literal>, otherwise PHP will interpret them as PHP
        options.
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-h and -?</entry>
     <entry>--help and --usage</entry>
     <entry>
      使用该参数，可以得到完整的命令行参数的列表及这些参数作用的简单描述。
     </entry>
    </row>
    <row>
     <entry>-i</entry>
     <entry>--info</entry>
     <entry>
      该命令行参数会调用 <function>phpinfo</function>
      函数并显示出结果。如果 PHP 没有正常工作，建议执行
      <command>php -i</command>
      命令来查看在信息表格之前或者对应的地方是否有任何错误信息输出。请注意当使用
      <acronym>CGI</acronym> 摸索时，输出的内容为 <acronym>HTML</acronym>
      格式，因此输出的信息篇幅较大。
     </entry>
    </row>
    <row>
     <entry>-l</entry>
     <entry>--syntax-check</entry>
     <entry>
      <para>
       该参数提供了对指定 PHP
       代码进行语法检查的方便的方法。如果成功，则向标准输出写入
       <literal>No syntax errors detected in &lt;filename&gt;</literal>
       字符串，并且外壳返回值为
       <literal>0</literal>。如果失败，则输出
       <literal>Errors parsing
        &lt;filename&gt;</literal>
       以及内部解析器错误信息到标准输出，同时外壳返回值将别设置为
       <literal>-1</literal>。
      </para>
      <para>
       该参数将无法检查致命错误（如未定义函数），如果也希望检测致命错误，请使用
       <option>-f</option> 参数。
      </para>
      <note>
       <para>
        该参数不能和 <option>-r</option> 一同使用。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-m</entry>
     <entry>--modules</entry>
     <entry>
      <para><example>
       <title>使用该参数，PHP 将打印出内置以及已加载的 PHP 及 Zend 模块：</title>
       <screen>
        <![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-r</entry>
     <entry>--run</entry>
     <entry>
      <para>
       使用该参数可以在命令行内运行单行 PHP
       代码。<emphasis role="strong">无需</emphasis>加上 PHP
       的起始和结束标识符（<literal>&lt;?php</literal> 和
       <literal>?&gt;</literal>），否则将会导致语法解析错误。
      </para>
      <note>
       <para>
        使用这种形式的 PHP 时，应注意避免和外壳环境进行的命令行参数替换相冲突。
       </para>
       <example>
        <title>显示双引号语法解析错误的范例</title>
        <screen>
         <![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
        </screen>
       </example>
       <para>
        这里的问题在于即使使用了双引号
        <literal>"</literal>，sh/bash 仍然实行了参数替换。由于
        <varname>$foo</varname>
        没有被定义，被替换后它所在的位置变成了空字符，因此在运行时，实际被
        PHP 读取的代码为：
       </para>
       <informalexample>
        <screen>
         <![CDATA[
$ php -r " = get_defined_constants();"
]]>
        </screen>
       </informalexample>

       <para>
        正确的方法是使用单引号
        <literal>'</literal>。在用单引号引用的字符串中，变量不会被
        sh/bash 还原成其原值。
       </para>
       <example>
        <title>Using single quotes to prevent the shell's variable
         substitution</title>
        <screen>
         <![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
        </screen>
       </example>
       <para>
        如果使用的外壳不是 sh/bash，可能会碰到更多问题。请将碰到的 Bug
        向 <link xlink:href="&url.php.bugs;">&url.php.bugs;</link>
        报告。注意，当试图将 shell 变量用到代码中或者使用反斜线时仍然很容易碰到问题。
       </para>
      </note>
      <note>
       <para>
        <option>-r</option> 在 &cli.sapi;
        中有效，在 <emphasis>CGI</emphasis> <acronym>SAPI</acronym> 中无效。
       </para>
      </note>
      <note>
       <para>
        此选项只用于非常基本的用途。因此一些配置指令（例如 <link
        linkend="ini.auto-prepend-file">auto_prepend_file</link> 和 <link
        linkend="ini.auto-append-file">auto_append_file</link>）在此模式下被忽略。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-B</entry>
     <entry>--process-begin</entry>
     <entry>
      <para>
       在处理 stdin 之前先执行 PHP 代码。
      </para>
     </entry>
    </row>
    <row>
     <entry>-R</entry>
     <entry>--process-code</entry>
     <entry>
      <para>
       对每个输入行都执行 PHP 代码。
      </para>
      <para>
       此模式下有两个特殊变量：<varname>$argn</varname>
       和 <varname>$argi</varname>。<varname>$argn</varname>
       包含 PHP 当前处理的行内容，而
       <varname>$argi</varname> 则包含该行号。
      </para>
     </entry>
    </row>
    <row>
     <entry>-F</entry>
     <entry>--process-file</entry>
     <entry>
      <para>
       对每个输入行都执行 PHP 文件。
      </para>
     </entry>
    </row>
    <row>
     <entry>-E</entry>
     <entry>--process-end</entry>
     <entry>
      <para>
       在处理完输入后执行的 PHP 代码。
      </para>
      <para><example>
       <title>
        使用 <option>-B</option>，<option>-R</option> 和
        <option>-E</option> 选项来计算一个项目总行数的例子。
       </title>
       <screen>
        <![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-S</entry>
     <entry>--server</entry>
     <entry>
      <para>
       Starts <link linkend="features.commandline.webserver">built-in web
       server</link>.
      </para>
     </entry>
    </row>
    <row>
     <entry>-t</entry>
     <entry>--docroot</entry>
     <entry>
      Specifies document root for <link
      linkend="features.commandline.webserver">built-in web server</link>.
     </entry>
    </row>
    <row>
     <entry>-s</entry>
     <entry>--syntax-highlight and --syntax-highlighting</entry>
     <entry>
      <para>
       显示有语法高亮色彩的源代码。
      </para>
      <para>
       该参数使用内建机制来解析文件并为其生成一个 HTML
       高亮版本并将结果写到标准输出。请注意该过程所做的只是生成了一个
       <literal>&lt;code&gt; [...] &lt;/code&gt;</literal> 的
       HTML 标记的块，并不包含任何的 HTML 头。
      </para>
      <note>
       <para>
        该选项不能和 <option>-r</option> 参数同时使用。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-v</entry>
     <entry>--version</entry>
     <entry>
      <para><example>
       <title>
        使用 <option>-v</option> 将 PHP、<acronym>SAPI</acronym> 名称和 Zend 的版本信息写入标准输出。
       </title>
       <screen>
        <![CDATA[
$ php -v
PHP 5.3.1 (cli) (built: Dec 11 2009 19:55:07)
Copyright (c) 1997-2009 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2009 Zend Technologies
]]>
       </screen>
      </example></para>
     </entry>
    </row>
    <row>
     <entry>-w</entry>
     <entry>--strip</entry>
     <entry>
      <para>
       显示除去了注释和多余空白的源代码。
      </para>
      <note>
       <para>
        该选项不能和 <option>-r</option> 参数同时使用。
       </para>
      </note>
     </entry>
    </row>
    <row>
     <entry>-z</entry>
     <entry>--zend-extension</entry>
     <entry>
      <para>
       加载 Zend 扩展库。如果仅给定一个文件名，PHP
       将试图从当前系统扩展库的默认路径（在 Linux
       系统下，该路径通常由 <filename>/etc/ld.so.conf</filename>
       指定）加载该扩展库。如果用一个绝对路径指定文件名，则不会使用系统的扩展库默认路径。如果用相对路径指定的文件名，则
       PHP 仅试图在当前目录的相对目录加载扩展库。
      </para>
     </entry>
    </row>
    <row>
     <entry></entry>
     <entry>--ini</entry>
     <entry>
      <para>
       Show configuration file names and scanned directories.
       <example>
        <title><literal>--ini</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--rf</entry>
     <entry>--rfunction</entry>
     <entry>
      <para>
       Show information about the given function or class method (e.g.
       number and name of the parameters).
      </para>
      <para>
       This option is only available if PHP was compiled with
       <link linkend="book.reflection">Reflection</link> support.
      </para>
      <para>
       <example>
        <title>basic <literal>--rf</literal> usage</title>
        <programlisting role="shell">
         <![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--rc</entry>
     <entry>--rclass</entry>
     <entry>
      <para>
       Show information about the given class (list of constants, properties
       and methods).
      </para>
      <para>
       This option is only available if PHP was compiled with
       <link linkend="book.reflection">Reflection</link> support.
      </para>
      <para>
       <example>
        <title><literal>--rc</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--re</entry>
     <entry>--rextension</entry>
     <entry>
      <para>
       Show information about the given extension (list of &php.ini; options,
       defined functions, constants and classes).
      </para>
      <para>
       This option is only available if PHP was compiled with
       <link linkend="book.reflection">Reflection</link> support.
      </para>
      <para>
       <example>
        <title><literal>--re</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
    <row>
     <entry>--rz</entry>
     <entry>--rzendextension</entry>
     <entry>
      <para>
       Show the configuration information for the given Zend extension (the
       same information that is returned by <function>phpinfo</function>).
      </para>
     </entry>
    </row>
    <row>
     <entry>--ri</entry>
     <entry>--rextinfo</entry>
     <entry>
      <para>
       Show the configuration information for the given extension (the same
       information that is returned by <function>phpinfo</function>).
       The core configuration information
       is available using "main" as extension name.
      </para>
      <para>
       <example>
        <title><literal>--ri</literal> example</title>
        <programlisting role="shell">
         <![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2009.20
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.930972 => 59.930972
date.default_longitude => 10.776699 => 10.776699
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
        </programlisting>
       </example>
      </para>
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</para>

<note>
 <para>
  Options <literal>-rBRFEH</literal>, <literal>--ini</literal> and
  <literal>--r[fcezi]</literal> are available only in &cli;.
 </para>
</note>
</section>
 <!--}}}-->

 <!--Usage: {{{-->
 <section xml:id="features.commandline.usage">
  <title>执行 PHP 文件</title>
  <titleabbrev>用法</titleabbrev>
  
  <para>
   &cli.sapi; 模块有以下三种不同的方法来获取要运行的 PHP 代码：
   <orderedlist>
    <listitem>
     <para>
      让 PHP 运行指定文件。
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php my_script.php

$ php -f my_script.php
]]>
      </screen>
     </informalexample>
     <para>
     以上两种方法（使用或不使用 <option>-f</option> 参数）都能够运行给定的
     <filename>my_script.php</filename> 文件。可以选择任何文件来运行，指定的
     PHP 脚本并非必须要以 <literal>.php</literal>
     为扩展名，它们可以有任意的文件名和扩展名。
     </para>
     <note>
      <para>
       如果在使用 <option>-f</option> 时需要将参数传递给脚本，则第一个参数必须是 <literal>--</literal>。
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      在命令行直接运行 PHP 代码。
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php -r 'print_r(get_defined_constants());'
]]>
      </screen>
     </informalexample>
     <para>
      必须特别注意外壳变量的替代及引号的使用。
     </para>
     <note>
      <para>
       请仔细阅读以上范例，在运行代码时没有开始和结束的标记符！加上
      <option>-r</option> 参数后，这些标记符是不需要的，加上它们会导致语法错误。
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      通过标准输入（<literal>stdin</literal>）提供需要运行的 PHP 代码。
     </para>
     <para>
      这提供了动态创建 PHP 代码并提供给二进制文件的强大能力，就像这个（虚构的）例子展示的一样：
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u > final_output.txt
]]>
      </screen>
     </informalexample>
    </listitem>
   </orderedlist>
   以上三种运行代码的方法不能组合使用。
  </para>
  
  <para>
  和所有的外壳应用程序一样，PHP 的二进制文件及其 PHP 脚本能够接受一系列的参数。PHP
  没有限制传送给脚本程序的参数的个数（外壳程序对命令行的字符数有限制，但通常都不会超过该限制）。传递给脚本的参数可在全局数组
  <varname>$argv</varname> 中获取。第一个索引（零）始终包含从命令行中调用脚本的名称。注意在命令行内使用 <option>-r</option>
  执行 PHP 代码， <varname>$argv[0]</varname> 的值将只是一个破折号（<literal>-</literal>）。
  如果代码是通过来自 <literal>STDIN</literal> 的管道执行的，同样如此。
  </para>

  <para>
   另外，全局变量
 <varname>$argc</varname> 存有 <varname>$argv</varname>
 数组中成员变量的个数（而<emphasis role="strong">非</emphasis>传送给脚本程序的参数的个数）。
  </para>
  
  <para>
   只要传送给脚本的参数不是以 <literal>-</literal>
  符号开头，就无需过多的注意什么。向脚本传送以
  <literal>-</literal> 开头的参数会导致错误，因为 PHP
  会认为应该由它自身来处理这些参数。可以用参数列表分隔符
  <literal>--</literal> 来解决这个问题。在 PHP
  解析完参数后，该符号后所有的参数将会被原样传送给脚本程序。
  </para>
  
  <informalexample>
   <screen>
<![CDATA[
# 以下命令将不会运行 PHP 代码，而只显示 PHP 命令行模式的使用说明：
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# 以下命令将会把“-h”参数传送给脚本程序，PHP 不会显示命令行模式的使用说明：
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
   </screen>
  </informalexample>
  
  <para>
   然而，在 Unix 系统中还有另一个方法将 PHP 用于外壳脚本：写一个使用 <literal>#!/usr/bin/php</literal>
   作为第一行开头的脚本（即便 PHP &cli; 二进制文件的路径跟默认不同）。文件的剩余部分应该包含通用 PHP 开始标签，正常的 PHP 代码，结束标签。
   一旦恰当设置了文件的执行属性（例如 <command>chmod +x test</command>），脚本就像是其他 shell/perl 脚本一样执行：
  </para>
  
  <example>
   <title>执行 PHP 脚本作为外壳脚本</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
   <para>
    假设改文件名为 <filename>test</filename> 并被放置在当前目录下，可以做如下操作：
   </para>
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
  </example>
  
  <para>
   正如所看到的，在向该脚本传送以 <literal>-</literal> 开头的参数时，脚本仍然能够正常运行。
  </para>
  
  <para>
   PHP 可执行文件可用于运行完全独立于 web 服务器的 PHP 脚本。在 Unix 系统上，需要在 PHP 脚本的第一行指定
   <literal>#!</literal>（或者说 “shebang”）以便系统可以自动判断用哪个程序运行脚本。
   在 Windows 平台下可以将 <filename>php.exe</filename> 和 <literal>.php</literal>
   文件的双击属性相关联，也可以编写一个批处理文件来用 PHP
   执行脚本。为 Unix 系统增加的第一行代码不会影响该脚本在 Windows
   下的运行，因此也可以用该方法编写跨平台的脚本程序。以下是一个简单的
   PHP 命令行程序的范例。
  </para>
  
  <para>
   <example>
    <title>试图以命令行方式运行的 PHP 脚本（script.php）</title>
    <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>
  
  <para>
   在以上脚本中，用第一行包含 Unix shebang 的代码来指明该文件应该由 PHP
   来执行。这里使用 &cli; 的版本，因此不会有 <acronym>HTTP</acronym> 头信息输出。
  </para>
  
  <para>
   程序首先检查是否有需要的参数（除了被计算在内的脚本名之外）。如果没有参数或者参数是 <option>--help</option>、
   <option>-help</option>、 <option>-h</option>、 <option>-?</option>，将会打印出帮助消息，
   使用 <varname>$argv[0]</varname> 在命令行上动态输出脚本的名称。否则参数将按照接收的方式进行准确回显。
  </para>
  
  <para>
   如果在 Unix 下运行以上脚本，必须是可执行的，并简单的运行 <command>script.php echothis</command> 或者
   <command>script.php -h</command>。在
   Windows 下，可以为此类任务编写类似与以下内容的批处理文件：
  </para>
  
  <para>
   <example>
    <title>运行 PHP 命令行脚本的批处理文件（script.bat）</title>
    <programlisting role="shell">
<![CDATA[
@echo OFF
"C:\php\php.exe" script.php %*
]]>
    </programlisting>
   </example>
  </para>
  
  <para>
   假设将上述程序命名为 <filename>script.php</filename>，且
   &cli; 版的 <filename>php.exe</filename> 位于 <filename>C:\php\php.exe</filename>，
   该批处理文件将会运行它，传递所有附加选项：
   <command>script.bat echothis</command> 或者 <command>script.bat -h</command>。
  </para>
  
  <para>
   参阅 <link linkend="ref.readline">Readline</link> 扩展文档获取更多函数，在 PHP
   中用于增强命令行应用程序。
  </para>
  
  <para>
   在 Windows 上， PHP可以配置为无需提供 <filename>C:\php\php.exe</filename> 或者
   <literal>.php</literal> 扩展运行，如 
   <link linkend="install.windows.commandline">PHP 在 Microsoft Windows 下的命令行方式</link>中所述。
  </para>

  <note>
   <para>
    在 Windows 上，推荐在真实用户账户下运行 PHP。因为在网络服务下运行某些操作将会失败，
    因为“帐户名与安全标识间无任何映射完成”。
   </para>
  </note>
 </section>
 <!--}}}-->


 <!--I/O Streams: {{{-->
 <section xml:id="features.commandline.io-streams">
  <title>输入输出流</title>
  <titleabbrev>I/O 流</titleabbrev>
  
  <para>
   &cli.sapi; 为 I/O 流定义了一些常量，以使命令行变量编程更容易一些。
  </para>
  
  <para>
   <table>
    <title>CLI 特定常量</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>常量</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><constant>STDIN</constant></entry>
       <entry>
        <para>一个已经打开的流到 <literal>stdin</literal>。使用如下方式节省打开它
       <programlisting role="php">
<![CDATA[
<?php
$stdin = fopen('php://stdin', 'r');
?>
]]>
       </programlisting>
       如果想从 <literal>stdin</literal> 中读取单行，可以使用
       <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // 从 STDIN 读取一行
fscanf(STDIN, "%d\n", $number); // 从 STDIN 读取数字
?>
]]>
       </programlisting>
       </para></entry>
      </row>
      <row>
       <entry><constant>STDOUT</constant></entry>
       <entry><para>
       一个已经打开的流到 <literal>stdout</literal>。使用如下方式节省打开它
       <programlisting role="php">
<![CDATA[
<?php
$stdout = fopen('php://stdout', 'w');
?>
]]>
       </programlisting>
       </para></entry>
      </row>
      <row>
       <entry><constant>STDERR</constant></entry>
       <entry>
        <para>
         一个已经打开的流到 <literal>stderr</literal>。使用如下方式节省打开它
         <programlisting role="php">
<![CDATA[
<?php
$stderr = fopen('php://stderr', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  
  <para>
   综上所述，就无需打开例如指向 <literal>stderr</literal> 的流，只需使用常量代替流资源：
   <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
   </programlisting>
   无须显式关闭这些流，因为它们会在脚本结束时由 PHP 自动关闭。
  </para>
  
  <note>
   <para>
    如果从 <literal>stdin</literal> 中读取 PHP 脚本，则这些常量不可用。
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Interactive shell: {{{-->
 <section xml:id="features.commandline.interactive">
  <title>交互式 shell</title>

  <para>
   如果 PHP 使用 <option role="configure">--with-readline</option> 选项编译的，则使用 <option>-a</option>
   选项时， &cli.sapi; 提供了交互式 shell。自 PHP 7.1.0 起，如果启用了 <link linkend="book.readline">readline extension</link>
   ，交互式 shell 也可以在 Windows 上使用。
  </para>

  <para>
   使用交互式 shell，你可以输入 PHP 代码并直接执行。
  </para>

  <example>
   <title>使用交互式 shell 执行代码</title>
   <programlisting role="shell">
<![CDATA[
$ php -a
Interactive shell

php > echo 5+8;
13
php > function addTwo($n)
php > {
php { return $n + 2;
php { }
php > var_dump(addtwo(2));
int(4)
php >
]]>
   </programlisting>
  </example>

  <para>
   交互式 shell 还具有对函数、常量、类名、变量、静态方法调用和类常量的 Tab 键补全功能。
  </para>

  <example>
   <title>Tab 键补全</title>
   <simpara>
    当可能有多个补全时，按两次 tab 键将会得到补全列表：
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strp[TAB][TAB]
strpbrk   strpos    strptime  
php > strp
]]>
   </programlisting>
   <simpara>
    当仅可能有一个补全的，按一次 Tab 键将在同一行中完成补全：
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strpt[TAB]ime(
]]>
   </programlisting>
   <simpara>
    补全也适用于当前交互式 shell 会话期间定义的名称：
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > $fooThisIsAReallyLongVariableName = 42;
php > $foo[TAB]ThisIsAReallyLongVariableName
]]>
   </programlisting>
  </example>

  <para>
   交互式 shell 存储你的历史记录，可以通过上下键访问。历史记录存储于 <filename>~/.php_history</filename> 文件。
  </para>

  <para>
   &cli.sapi; 提供了 &php.ini; 设置： <parameter>cli.pager</parameter> 和
   <parameter>cli.prompt</parameter>。 <parameter>cli.pager</parameter>
   设置语序外部程序（例如 <filename>less</filename>)）充当分页器输出而不是直接显示在屏幕上。
   <parameter>cli.prompt</parameter> 设置可以更改 <literal>php &gt;</literal> 提示符。
  </para>

  <para>
   在交互式 shell 中还可以使用缩写符号设置 &php.ini; 设置。
  </para>

  <example>
   <title>在交互式 shell 中设置 &php.ini; 设置</title>
   <simpara>
    <parameter>cli.prompt</parameter> 设置：
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=hello world :> 
hello world :> 
]]>
   </programlisting>
   <simpara>
    使用反引号可以在提示中执行 PHP 代码：
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=`echo date('H:i:s');` php > 
15:49:35 php > echo 'hi';
hi
15:49:43 php > sleep(2);
15:49:45 php > 
]]>
   </programlisting>
   <simpara>
    设置分页器为 <filename>less</filename>：
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.pager=less
php > phpinfo();
(output displayed in less)
php > 
]]>
   </programlisting>
  </example>

  <para>
   <parameter>cli.prompt</parameter> 设置支持一些转义字符：
   <table>
    <title><parameter>cli.prompt</parameter> 转义字符</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>字符</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>
        用于添加提示颜色。一个例子可能是 <literal>\e[032m\v \e[031m\b \e[34m\> \e[0m</literal>
       </entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>PHP 版本</entry>
      </row>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>
        指明 PHP 所在的块。例如 <literal>/*</literal> 表示在多行注释中。外部作用域用 <literal>php</literal> 来表示。
       </entry>
      </row>
      <row>
       <entry><literal>\&gt;</literal></entry>
       <entry>
        指明提示字符。默认情况下是 <literal>&gt;</literal>，但 shell 位于未结束的块或者字符串时会发生变化。可能的字符有
        <literal>' " { ( &gt;</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <para>
    在该模式下，通过 <link linkend="ini.auto-prepend-file">auto_prepend_file</link> 和 <link
    linkend="ini.auto-append-file">auto_append_file</link> 解析文件包含会有一些限制 —— 例如函数必须在调用前定义。
   </para>
  </note>

  <section xml:id="features.commandline.interactive.mode">
   <title>交互模式</title>
   <para>
    如果 readline 扩展不可用，在 PHP 8.1.0 之前，使用 <option>-a</option> 选项调用 &cli.sapi; 会提供交互模式。
    在此模式中，一个完整的 PHP 脚本应该通过 STDIN 给出，并用 <literal>CRTL+d</literal> （POSIX） 或者 <literal>CTRL+z</literal>
    接着是 <literal>ENTER</literal> （Windows）后停止，脚本执行。这与不加 <option>-a</option> 选项调用 &cli.sapi; 基本相同。
   </para>
   <para>
    自 PHP 8.1.0 起，如果 readline 扩展不可用，使用 <option>-a</option> 调用 &cli.sapi; 会失败。
   </para>
  </section>
</section>
 <!--}}}-->

 <!--Built-in CLI Web Server: {{{-->
 <section xml:id="features.commandline.webserver">
  <title>内置Web Server</title>

  <para>
   &cli.sapi; 提供了一个内置的Web服务器。
  </para>
<para>   
   这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。
  </para>

  <para>
     URI请求会被发送到PHP所在的的工作目录（Working Directory）进行处理，除非你使用了-t参数来自定义不同的目录。
  </para>

  <para>
  
   如果请求未指定执行哪个PHP文件，则默认执行目录内的index.php 或者 index.html。如果这两个文件都不存在，服务器会返回404错误。
  </para>

  <para>  
   
   当你在命令行启动这个Web Server时，如果指定了一个PHP文件，则这个文件会作为一个“路由”脚本，意味着每次请求都会先执行这个脚本。如果这个脚本返回 &false; ，那么直接返回请求的文件（例如请求静态文件不作任何处理）。否则会把输出返回到浏览器。
  </para>

  <example>
   <title>启动Web服务器</title> 
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000
]]>
   </programlisting>
   <para>
     终端窗口会显示:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
]]>
   </screen>
   <para>   
    
    接着访问http://localhost:8000/和http://localhost:8000/myscript.html，窗口会显示：
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
]]>
   </screen>
  </example>

  <example>
   <title>启动时指定根目录</title> 
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000 -t foo/
]]>
   </programlisting>
   <para>
     终端窗口显示：
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
]]>
   </screen>
  </example>

  <example>
   <title>使用路由（Router）脚本</title> 
<para>
 
 请求图片直接显示图片，请求HTML则显示“Welcome to PHP”
</para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"]))
    return false;    // 直接返回请求的文件
else { 
    echo "<p>Welcome to PHP</p>";
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
   <para>
    
    执行之后终端显示：
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:53:19 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:53:45 2011] ::1:55801 GET /mylogo.jpg - Request read
[Thu Jul 21 10:53:52 2011] ::1:55803 GET /abc.html - Request read
[Thu Jul 21 10:53:52 2011] ::1:55804 GET /favicon.ico - Request read
]]>
   </screen>
  </example>
  <example>
   <title>Checking for CLI Web Server Use</title>
   <para>
    To reuse a framework router script during development with the CLI web server and later also with a production web server:
   </para>
   <programlisting role="php">
    <![CDATA[
<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* route static assets and return false */
}
/* go on with normal index.php operations */
?>]]>
   </programlisting>
   <programlisting role="shell">
    <![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Handling Unsupported File Types</title>
   <para>
    If you need to serve a static resource whose MIME type is not handled by the CLI web server, use:
   </para>
   <programlisting role="php">
    <![CDATA[
<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>]]>
   </programlisting>
   <programlisting role="shell">
    <![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Accessing the CLI Web Server From Remote Machines</title>
   <para>
    You can make the web server accessible on port 8000 to any interface with:
   </para>
   <programlisting role="shell">
    <![CDATA[
$ php -S 0.0.0.0:8000
]]>
   </programlisting>
   <warning>
    <para>
     The built-in Web Server should not be used on a public network.
    </para>
   </warning>
  </example>

 </section>
 <!--}}}-->

  <section xml:id="features.commandline.ini">
   <title>INI 配置</title>
   <para>
    <table>
     <title>CLI SAPI 配置选项</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>&Name;</entry>
        <entry>&Default;</entry>
        <entry>&Changeable;</entry>
        <entry>&Changelog;</entry>
       </row>
      </thead>
      <tbody xml:id="features.commandline.ini.list">
       <row>
        <entry><link linkend="ini.cli-server.color">cli_server.color</link></entry>
        <entry>"0"</entry>
        <entry>PHP_INI_ALL</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   
   &ini.descriptions.title;
   
   <para>
    <variablelist>
     <varlistentry xml:id="ini.cli-server.color">
      <term>
       <parameter>cli_server.color</parameter>
       <type>boolean</type>
      </term>
      <listitem>
       <para>        
        控制内置Web Server的终端输出有无颜色。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
