<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.3 $ -->
<!-- $AUTHOR$ -->
<!-- EN-Revision: 1.1 Maintainer: class007 Status: working -->
<appendix id="migration">
 <title>从 PHP/FI 2 移植到 PHP 3</title>

 <section id="migration.about">
  <title>关于 PHP 3.0 的不兼容性</title>

  <simpara>
   PHP 3.0 从底层重写了代码。它有着比 2.0 更健壮和统一的解析器。3.0 也更快、占用更少的内存。但是，这些改进难以避免兼容性的削弱，包括语法和功能上兼容性的削弱。
  </simpara>

  <simpara>
   另外，PHP 的开发者尝试在版本 3.0 中使得 PHP 的语法和语义更加简洁，这也导致了一些不兼容。最后，我们相信这些改变是值得的。  </simpara>

  <simpara>
   本章将会指导你认识从 PHP/FI 2.0 到 PHP 3.0 升级所带来的的障碍并帮助你解决它。这里没有提到 3.0 的新功能，除非必要。
  </simpara>

  <simpara>
   一个转换程序可以帮助您自动转换旧有的 PHP/FI 2.0 脚本。这个程序可以在 PHP 3.0 发布包中的 <filename class="directory">convertor</filename> 子目录中找到。可是，该程序只能转换语法的改变，因此，您仍然需要仔细阅读下面的部分。  </simpara>
 </section>

 <section id="migration.startendtags">
  <title>开始/结束标记</title>

  <para>
   首先您应该注意 PHP 的开始/结束标记已经改变。老的 <literal>&lt;? &gt;</literal> 已经被三种新的形式所替换：
   <example>
    <title>Migration: old start/end tags</title>
    <programlisting role="php">
<![CDATA[
<? echo "This is PHP/FI 2.0 code.\n"; ?>
]]>
    </programlisting>
   </example>
   As of version 2.0, PHP/FI also supports this variation:
   <example>
    <title>Migration: first new start/end tags</title>
    <programlisting role="php">
<![CDATA[
<? echo "This is PHP 3.0 code!\n"; ?>
]]>
    </programlisting>
   </example>

   Notice that the end tag now consists of a question mark and a
   greater-than character instead of just greater-than.  However, if
   you plan on using XML on your server, you will get problems with
   the first new variant, because PHP may try to execute the XML
   markup in XML documents as PHP code.  Because of this, the
   following variation was introduced:

   <example>
    <title>Migration: second new start/end tags</title>
    <programlisting role="php">
<![CDATA[
<?php echo "This is PHP 3.0 code!\n"; ?>
]]>
    </programlisting>
   </example>

   Some people have had problems with editors that don't understand
   the processing instruction tags at all.  Microsoft FrontPage is one
   such editor, and as a workaround for these, the following variation
   was introduced as well:

   <example>
    <title>Migration: third new start/end tags</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "This is PHP 3.0 code!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration.if-endif">
  <title>if..endif syntax</title>

  <para>
   The `alternative' way to write if/elseif/else statements, using if();
   elseif(); else; endif; cannot be efficiently implemented without
   adding a large amount of complexity to the 3.0 parser.  Because of
   this, the syntax has been changed:
   <example>
    <title>Migration: old if..endif syntax</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "yep\n";
elseif ($bar);
    echo "almost\n";
else;
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration: new if..endif syntax</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "yep\n";
elseif ($bar):
    echo "almost\n";
else:
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>

   Notice that the semicolons have been replaced by colons in all
   statements but the one terminating the expression (endif).
  </para>
 </section>

 <section id="migration-while">
  <title>while syntax</title>
  <para>
   Just like with if..endif, the syntax of while..endwhile has changed
   as well:
   <example>
    <title>Migration: old while..endwhile syntax</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration: new while..endwhile syntax</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    If you use the old while..endwhile syntax in PHP 3.0,
    you will get a never-ending loop.
   </simpara>
  </warning>
 </section>

 <section id="migration.expr">
  <title>Expression types</title>
  <simpara>
   PHP/FI 2.0 used the left side of expressions to determine what type
   the result should be.  PHP 3.0 takes both sides into account when
   determining result types, and this may cause 2.0 scripts to behave
   unexpectedly in 3.0.
  </simpara>
  <para>
   Consider this example:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   In PHP/FI 2.0, this would display both of $a's indices.  In PHP
   3.0, it wouldn't display anything.  The reason is that in PHP 2.0,
   because the left argument's type was string, a string comparison
   was made, and indeed <literal>""</literal> does not equal
   <literal>"0"</literal>, and the loop went through.  In PHP 3.0,
   when a string is compared with an integer, an integer comparison is
   made (the string is converted to an integer).  This results in
   comparing <literal>atoi("")</literal> which is
   <literal>0</literal>, and <literal>variablelist</literal> which is
   also <literal>0</literal>, and since <literal>0==0</literal>, the
   loop doesn't go through even once.
  </para>
  <para>
   The fix for this is simple.  Replace the while statement with:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section id="migration.errors">
  <title>Error messages have changed</title>
  <simpara>
   PHP 3.0's error messages are usually more accurate than 2.0's were,
   but you no longer get to see the code fragment causing the error.
   You will be supplied with a file name and a line number for the
   error, though.
  </simpara>
 </section>

 <section id="migration.booleval">
  <title>Short-circuited boolean evaluation</title>
  <simpara>
   In PHP 3.0 boolean evaluation is short-circuited.  This means that
   in an expression like <literal>(1 || test_me())</literal>, the
   function <function>test_me</function> would not be executed since
   nothing can change the result of the expression after the
   <literal>1</literal>.
  </simpara>

  <simpara>
   This is a minor compatibility issue, but may cause unexpected
   side-effects.
  </simpara>
 </section>

 <section id="migration.truefalse">
  <title>Function &true;/&false; return values</title>
  <simpara>
   Most internal functions have been rewritten so they return &true;
   when successful and &false; when failing, as opposed to 0 and -1 in
   PHP/FI 2.0, respectively. The new behaviour allows for more
   logical code, like <literal>$fp = fopen("/your/file") or
   fail("darn!");</literal>. Because PHP/FI 2.0 had no clear rules
   for what functions should return when they failed, most such
   scripts will probably have to be checked manually after using the
   2.0 to 3.0 convertor.
  </simpara>
  <para>
   <example>
    <title>Migration from 2.0: return values, old code</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Could not open $file for reading<br>\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration from 2.0: return values, new code</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Could not open $file for reading<br>\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration-other">
  <title>Other incompatibilities</title>

  <itemizedlist>
   <listitem><simpara>
    The PHP 3.0 Apache module no longer supports Apache versions
    prior to 1.2.  Apache 1.2 or later is required.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> no longer supports a format string.
    Use the <function>printf</function> function instead.
   </simpara></listitem>

   <listitem><simpara>
    In PHP/FI 2.0, an implementation side-effect caused
    <literal>$foo[0]</literal> to have the same effect as
    <literal>$foo</literal>. This is not true for PHP 3.0.
   </simpara></listitem>

   <listitem>
    <simpara>
     Reading arrays with <literal>$array[]</literal> is no longer
     supported
    </simpara>
    <simpara>
     That is, you cannot traverse an array by having a loop that does
     <literal>$data = $array[]</literal>.  Use <function>current</function>
     and <function>next</function> instead.
    </simpara>
    <simpara>
     Also, <literal>$array1[] = $array2</literal> does not
     append the values of <literal>$array2</literal> to
     <literal>$array1</literal>, but appends
     <literal>$array2</literal> as the last entry of
     <literal>$array1</literal>. See also multidimensional array
     support.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> is no longer overloaded as a
     concatenation operator for strings, instead it converts it's
     arguments to numbers and performs numeric addition. Use
     <literal>"."</literal> instead.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migration from 2.0: concatenation for strings</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    In PHP 2.0 this would echo 11, in PHP 3.0 it would
    echo 2. Instead use:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    This would echo 2 in both PHP 2.0 and 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    This will echo 11 in PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
