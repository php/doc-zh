<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- $Author$ -->
<!-- $EN-Revision: 96c9d88bad9a7d7d44bfb7f26c226df7ee9ddf26 $ -->
<appendix xml:id="filters"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>可用过滤器列表</title>
  <para>下面列出了用在 
  <function>stream_filter_append</function>中的几个内置的流过滤器。用户的 PHP 版本中的过滤器也许比这里列出的更多（或更少）。</para>
  <para>值得指出 
  <function>stream_filter_append</function>与 
  <function>stream_filter_prepend</function>之间有少许不平衡。每个 PHP 流都含有一个小的
  <emphasis>读取缓冲区</emphasis>，它存储了来自文件系统或其它资源的几段数据以便更有效率地处理。数据一从资源进入流的内部缓冲区，立刻被附上的过滤器处理而不管 PHP 程序是否真的已经准备好接收数据。当过滤器是 
  <emphasis>appended</emphasis>时如果数据等待在读取缓冲区，数据将被立即通过过滤器处理，使其效果看上去是透明的。然而当过滤器是 
  <emphasis>prepended</emphasis>时如果数据等待在读取缓冲区，数据将
  <emphasis>不会</emphasis>被该过滤器处理。该数据将会等到从资源取得下一段数据后才会被处理。</para>
  <para>用 
  <function>stream_get_filters</function>来列出 PHP 中已安装的过滤器。</para>
  <section xml:id="filters.string">
    <title>字符串过滤器</title>
    <simpara>每个过滤器都正如其名字暗示的那样工作并与内置的 PHP 字符串函数的行为相对应。对于指定过滤器的更多信息，请参考该函数的手册页。</simpara>
    <simpara>
    <literal>string.rot13</literal>（自 PHP 4.3.0 起）使用此过滤器等同于用 
    <function>str_rot13</function>函数处理所有的流数据。</simpara>
    <example>
      <title>string.rot13</title>
      <programlisting role="php">
        <![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.rot13');
fwrite($fp, "This is a test.\n");
/* Outputs:  Guvf vf n grfg.   */
?>
]]>
</programlisting>
    </example>
    <simpara>
    <literal>string.toupper</literal>（自 PHP 5.0.0 起）使用此过滤器等同于用 
    <function>strtoupper</function>函数处理所有的流数据。</simpara>
    <example>
      <title>string.toupper</title>
      <programlisting role="php">
        <![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.toupper');
fwrite($fp, "This is a test.\n");
/* Outputs:  THIS IS A TEST.   */
?>
]]>
</programlisting>
    </example>
    <simpara>
    <literal>string.tolower</literal>（自 PHP 5.0.0 起）使用此过滤器等同于用 
    <function>strtolower</function>函数处理所有的流数据。</simpara>
    <example>
      <title>string.tolower</title>
      <programlisting role="php">
        <![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.tolower');
fwrite($fp, "This is a test.\n");
/* Outputs:  this is a test.   */
?>
]]>
</programlisting>
    </example>
    <simpara>
    <literal>string.strip_tags</literal>（自 PHP 5.0.0 起）使用此过滤器等同于用 
    <function>strip_tags</function>函数处理所有的流数据。可以用两种格式接收参数：一种是和 
    <function>strip_tags</function>函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。</simpara>
    <example>
      <title>string.strip_tags</title>
      <programlisting role="php">
        <![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "<b><i><u>");
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */
?>
]]>
</programlisting>
    </example>
  </section>
  <section xml:id="filters.convert">
    <title>转换过滤器</title>
    <simpara>如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的。对于指定过滤器的更多信息，请参考该函数的手册页。</simpara>
    <simpara>
    <literal>convert.base64-encode</literal>和 
    <literal>convert.base64-decode</literal>使用这两个过滤器等同于分别用 
    <function>base64_encode</function>和 
    <function>base64_decode</function>函数处理所有的流数据。
    <literal>convert.base64-encode</literal>支持以一个关联数组给出的参数。如果给出了 
    <parameter>line-length</parameter>，base64 输出将被用 
    <parameter>line-length</parameter>个字符为 长度而截成块。如果给出了 
    <parameter>line-break-chars</parameter>，每块将被用给出的字符隔开。这些参数的效果和用 
    <function>base64_encode</function>再加上 
    <function>chunk_split</function>相同。</simpara>
    <example>
      <title>convert.base64-encode &amp; convert.base64-decode</title>
      <programlisting role="php">
        <![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBpcyBhIHRlc3QuCg==  */

$param = array('line-length' => 8, 'line-break-chars' => "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBp
          :  cyBhIHRl
          :  c3QuCg==  */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
/* Outputs:  This is a test.  */
?>
]]>
</programlisting>
    </example>
    <simpara>
    <literal>convert.quoted-printable-encode</literal>和 
    <literal>convert.quoted-printable-decode</literal>使用此过滤器的 decode 版本等同于用 
    <function>quoted_printable_decode</function>函数处理所有的流数据。没有和 
    <literal>convert.quoted-printable-encode</literal>相对应的函数。
    <literal>convert.quoted-printable-encode</literal>支持以一个关联数组给出的参数。除了支持和 
    <literal>convert.base64-encode</literal>一样的附加参数外，
    <literal>convert.quoted-printable-encode</literal>还支持布尔参数 
    <parameter>binary</parameter>和 
    <parameter>force-encode-first</parameter>。
    <literal>convert.base64-decode</literal>只支持 
    <parameter>line-break-chars</parameter>参数作为从编码载荷中剥离的类型提示。</simpara>
    <example>
      <title>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</title>
      <programlisting role="php">
        <![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.quoted-printable-encode');
fwrite($fp, "This is a test.\n");
/* Outputs:  =This is a test.=0A  */
?>
]]>
</programlisting>
    </example>
  </section>
  <section xml:id="filters.compression">
    <title>压缩过滤器</title>
    <simpara>虽然
    <link linkend="wrappers.compression">压缩封装协议</link>提供了在本地文件系统中 创建 gzip 和 bz2 兼容文件的方法，但不代表可以在网络的流中提供通用压缩的意思，也不代表可以将一个非压缩的流转换成一个压缩流。对此，压缩过滤器可以在任何时候应用于任何流资源。</simpara>
    <note>
      <simpara>压缩过滤器
      <emphasis>不</emphasis>产生命令行工具如 
      <literal>gzip</literal>的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</simpara>
    </note>
    <simpara>
    <literal>zlib.deflate</literal>（压缩）和 
    <literal>zlib.inflate</literal>（解压）实现了定义与 
    <link xlink:href="&url.rfc;1951">RFC 1951</link>的压缩算法。
    <literal>deflate</literal>过滤器可以接受以一个关联数组传递的最多三个参数。
    <parameter>level</parameter>定义了压缩强度（1-9）。数字更高通常会产生更小的载荷，但要消耗更多的处理时间。存在两个特殊压缩等级：0（完全不压缩）和 -1（zlib 内部默认值，目前是 6）。
    <parameter>window</parameter>是压缩回溯窗口大小，以二的次方表示。更高的值（大到 15 —— 32768 字节）产生更好的压缩效果但消耗更多内存，低的值（低到 9 —— 512 字节）产生产生较差的压缩效果但内存消耗低。目前默认的 
    <parameter>window</parameter>大小是 
    <constant>15</constant>。
    <parameter>memory</parameter>用来指示要分配多少工作内存。合法的数值范围是从 1（最小分配）到 9（最大分配）。内存分配仅影响速度，不会影响生成的载荷的大小。</simpara>
    <note>
      <simpara>因为最常用的参数是压缩等级，也可以提供一个整数值作为此参数（而不用数组）。</simpara>
    </note>
    <simpara>zlib.* 压缩过滤器自 PHP 版本 
    <literal>5.1.0</literal>起可用，在激活 
    <link linkend="ref.zlib">zlib</link>的前提下。也可以通过安装来自 
    <link xlink:href="&url.pecl;">PECL</link>的 
    <link xlink:href="&url.pecl.package;zlib_filter">zlib_filter</link>包作为一个后门在 
    <literal>5.0.x</literal>版中使用。此过滤器在 PHP 4 中
    <emphasis>不可用</emphasis>。</simpara>
    <example>
      <title>
      <literal>zlib.deflate</literal>和 
      <literal>zlib.inflate</literal></title>
      <programlisting role="php">
        <![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";
echo "The original text was:\n";
/* Use readfile and zlib.inflate to decompress on the fly */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.
The original text was:
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
</programlisting>
    </example>
    <example>
      <title>
      <literal>zlib.deflate</literal>简单参数用法</title>
      <programlisting role="php">
        <![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
/* Here "6" indicates compression level 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.

 */
?>
]]>
</programlisting>
    </example>
    <simpara>
    <literal>bzip2.compress</literal>和 
    <literal>bzip2.decompress</literal>工作的方式与上面讲的 zlib 过滤器相同。
    <literal>bzip2.compress</literal>过滤器接受以一个关联数组给出的最多两个参数：
    <parameter>blocks</parameter>是从 1 到 9 的整数值，指定分配多少个 100K 字节的内存块作为工作区。
    <parameter>work</parameter>是 0 到 250 的整数值，指定在退回到一个慢一些，但更可靠的算法之前做多少次常规压缩算法的尝试。调整此参数仅影响到速度，压缩输出和内存使用都不受此设置的影响。将此参数设为 0 指示 bzip 库使用内部默认算法。
    <literal>bzip2.decompress</literal>过滤器仅接受一个参数，可以用普通的布尔值传递，或者用一个关联数组中的 
    <parameter>small</parameter>单元传递。当 
    <parameter>small</parameter>设为 &amp;true; 值时，指示 bzip 库用最小的内存占用来执行解压缩，代价是速度会慢一些。</simpara>
    <simpara>bzip2.* 压缩过滤器自 PHP 版本 
    <literal>5.1.0</literal>起可用，在激活 
    <link linkend="ref.bzip2">bz2</link>支持的前提下。也可以通过安装来自 
    <link xlink:href="&url.pecl;">PECL</link>的
    <link xlink:href="&url.pecl.package;bz2_filter">bz2_filter</link>包作为一个后门在 
    <literal>5.0.x</literal>版中使用。此过滤器在 PHP 4 中
    <emphasis>不可用</emphasis>。</simpara>
    <example>
      <title>
      <literal>bzip2.compress</literal>和 
      <literal>bzip2.decompress</literal></title>
      <programlisting role="php">
        <![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "The original file is " . filesize('LICENSE') . " bytes long.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "The compressed file is " . filesize('LICENSE.compressed') . " bytes long.\n";

/* Generates output:

The original text is 3288 characters long.
The compressed file is 1488 bytes long.

 */
?>
]]>
</programlisting>
    </example>
  </section>
  <section xml:id="filters.encryption">
    <title>加密过滤器</title>
    <simpara>
    <literal>mcrypt.*</literal>和 
    <literal>mdecrypt.*</literal>使用 libmcrypt 提供了对称的加密和解密。这两组过滤器都支持 
    <link linkend="ref.mcrypt">mcrypt 扩展库</link>中相同的算法，格式为 
    <literal>mcrypt.ciphername</literal>，其中 
    <parameter>ciphername</parameter>是密码的名字，将被传递给 
    <function>mcrypt_module_open</function>。有以下五个过滤器参数可用：</simpara>
    <para>
      <table>
        <title>mcrypt 过滤器参数</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>参数</entry>
              <entry>是否必须</entry>
              <entry>默认值</entry>
              <entry>取值举例</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>mode</entry>
              <entry>可选</entry>
              <entry>cbc</entry>
              <entry>cbc, cfb, ecb, nofb, ofb, stream</entry>
            </row>
            <row>
              <entry>algorithms_dir</entry>
              <entry>可选</entry>
              <entry>ini_get(&#39;mcrypt.algorithms_dir&#39;)</entry>
              <entry>algorithms 模块的目录</entry>
            </row>
            <row>
              <entry>modes_dir</entry>
              <entry>可选</entry>
              <entry>ini_get(&#39;mcrypt.modes_dir&#39;)</entry>
              <entry>modes 模块的目录</entry>
            </row>
            <row>
              <entry>iv</entry>
              <entry>必须</entry>
              <entry>N/A</entry>
              <entry>典型为 8，16 或 32 字节的二进制数据。根据密码而定</entry>
            </row>
            <row>
              <entry>key</entry>
              <entry>必须</entry>
              <entry>N/A</entry>
              <entry>典型为 8，16 或 32 字节的二进制数据。根据密码而定</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </para>
    <example>
      <title>用 3DES 将文件加密输出</title>
      <programlisting role="php">
        <![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) .
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'wb');
stream_filter_append($fp, 'mcrypt.tripledes', STREAM_FILTER_WRITE, $opts);
fwrite($fp, 'Secret secret secret data');
fclose($fp);
?>
]]>
</programlisting>
    </example>
    <example>
      <title>读取加密的文件</title>
      <programlisting role="php">
        <![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) .
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'rb');
stream_filter_append($fp, 'mdecrypt.tripledes', STREAM_FILTER_WRITE, $opts);
$data = rtrim(stream_get_contents($fp));
fclose($fp);

echo $data;
?>
]]>
</programlisting>
    </example>
  </section>
</appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
