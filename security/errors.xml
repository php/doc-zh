<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: n/a Maintainer: lm92 Status: ready -->
<!-- CREDITS: dallas -->
  <chapter xml:id="security.errors" xmlns="http://docbook.org/ns/docbook">
   <title>错误报告</title>
   <para>
    对于 PHP 的安全性来说错误报告是一把双刃剑。一方面可以提高安全性，另一方面又有害。
   </para>
   <para>
    标准的攻击策略是通过输入不正确的数据来分析系统，然后查看返回的错误的类型及上下文。这样做有利于攻击者收集服务器的信息以便寻找弱点。
    比如说，如果攻击者根据先前的表单提交收集了有关页面的信息，那么他就会尝试覆盖或者修改变量：
    <example>
     <title>使用自定义 HTML 页面攻击变量</title>
     <programlisting role="html">
<![CDATA[
<form method="post" action="attacktarget?username=badfoo&amp;password=badfoo">
<input type="hidden" name="username" value="badfoo" />
<input type="hidden" name="password" value="badfoo" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    通常返回的 PHP 错误对于尝试调试脚本的开发人员非常有帮助，指出失败发生的函数，行号等信息。
    这是所有可以利用的信息。PHP 开发人员使用 <function>show_source</function> 、
    <function>highlight_string</function> 、 <function>highlight_file</function>
    作为调试办法并不少见，但在运行的网站中，这可能会暴露隐藏的变量、未检查的语法和其他危险的信息。
    使用内置调试处理程序或者常见调试方法来运行已知来源的代码尤其危险。
    如果攻击者可以确定使用的哪种常规方法，他们可能会尝试通过发送各种常见的调试字符串来暴力破解页面：
    <example>
     <title>利用常见的调试变量</title>
     <programlisting role="html">
<![CDATA[
<form method="post" action="attacktarget?errors=Y&amp;showerrors=1&amp;debug=1">
<input type="hidden" name="errors" value="Y" />
<input type="hidden" name="showerrors" value="1" />
<input type="hidden" name="debug" value="1" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    不管错误处理方法如何，探测系统错误的能力会给攻击者提供更多信息。
   </para>
   <para>
    例如，通用的 PHP 错误风格表明系统正在运行 PHP。如果攻击者正在寻找 .html 
    页面，想要探查后端（以查找系统中的已知弱点），
    通过提供错误的数据，它们可能能够确定系统是使用 PHP 构建的。
   </para>
   <para>
    A function error can indicate whether a system may be running a
    specific database engine, or give clues as to how a web page or
    programmed or designed. This allows for deeper investigation into
    open database ports, or to look for specific bugs or weaknesses
    in a web page. By feeding different pieces of bad data, for example,
    an attacker can determine the order of authentication in a script,
    (from the line number errors) as well as probe for exploits that
    may be exploited in different locations in the script.
   </para>
   <para>
    A filesystem or general PHP error can indicate what permissions
    the web server has, as well as the structure and organization of
    files on the web server. Developer written error code can aggravate
    this problem, leading to easy exploitation of formerly "hidden"
    information.
   </para>
   <para>
    There are three major solutions to this issue. The first is to
    scrutinize all functions, and attempt to compensate for the bulk
    of the errors. The second is to disable error reporting entirely
    on the running code. The third is to use PHP's custom error
    handling functions to create your own error handler. Depending
    on your security policy, you may find all three to be applicable
    to your situation.
   </para>
   <para>
    One way of catching this issue ahead of time is to make use of
    PHP's own <function>error_reporting</function>, to help you
    secure your code and find variable usage that may be dangerous.
    By testing your code, prior to deployment, with <constant>E_ALL</constant>,
    you can quickly find areas where your variables may be open to poisoning
    or modification in other ways. Once you are ready for deployment,
    you should either disable error reporting completely by setting
    <function>error_reporting</function> to 0, or turn off the error
    display using the &php.ini; option <literal>display_errors</literal>,
    to insulate your code from probing. If you choose to do the latter,
    you should also define the path to your log file using the
    <literal>error_log</literal> ini directive, and turn
    <literal>log_errors</literal> on.
    <example>
     <title>用 E_ALL 来查找危险的变量</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // Not initialized or checked before usage
    $good_login = 1;
}
if ($good_login == 1) { // If above test fails, not initialized or checked before usage
    readfile ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
