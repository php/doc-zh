<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: c5d92fd7127e059d448d43ba339f19956f83b05a Maintainer: lm92 Status: ready -->
<!-- CREDITS: dallas, mowangjuanzi -->
  <chapter xml:id="security.filesystem" xmlns="http://docbook.org/ns/docbook">
   <title>文件系统安全</title>
   <simpara>
    <acronym>PHP</acronym> 取决于大多数服务器系统中关于文件和目录权限的内置安全机制。
    这允许控制文件系统中那些文件是可读的。应该小心对待任何全局可读的文件，
    确保所有有权访问文件系统的用户都可以安全的读取。
   </simpara>
   <simpara>
    自 <acronym>PHP</acronym> 被设计为允许用户级别访问文件系统以来，
    完全可以编写 <acronym>PHP</acronym> 脚本，允许读取系统文件，例如 /etc/passwd，
    修改网络连接，发送大量打印任务等。这有一些明显的影响，因为需要确保读写的是合适的文件。
   </simpara>
   <simpara>
    请看下面的脚本，用户表示想要删除家目录下的一个文件。
    假设一个情况， <acronym>PHP</acronym> web 界面经常用于文件管理，
    因此 Apache 用户允许删除用户家目录中的文件。
   </simpara>
   <para>
    <example>
     <title>差的变量检查会导致....</title>
     <programlisting role="php">
<![CDATA[
<?php
// 从用户家目录移除一个文件
$username = $_POST['user_submitted_name'];
$userfile = $_POST['user_submitted_filename'];
$homedir  = "/home/$username";

unlink("$homedir/$userfile");

echo "The file has been deleted!";
?>
]]>
     </programlisting>
    </example>
   由于 username 和 filename 由用户表单中提交，那就能提交属于其他人的 username
   和 filename 并删除它们，即使不应该也不允许这么做。在这种情况下，
   想使用一些其他的身份验证表单。考虑一下，如果提交的变量是 "../etc/" 和 "passwd"。
   然后代码将会有效的读取：
    <example>
     <title>... 文件系统攻击</title>
     <programlisting role="php">
<![CDATA[
<?php
// 从 PHP 用户有权访问的磁盘驱动器上任何位置删除一个文件。
// 如果 PHP 有 root 访问权限：
$username = $_POST['user_submitted_name']; // "../etc"
$userfile = $_POST['user_submitted_filename']; // "passwd"
$homedir  = "/home/$username"; // "/home/../etc"

unlink("$homedir/$userfile"); // "/home/../etc/passwd"

echo "The file has been deleted!";
?>
]]>
     </programlisting>
    </example>
    应该采取两项重要措施来防止这类问题。
    <itemizedlist>
     <listitem>
      <simpara>
       <acronym>PHP</acronym> web 用户二进制文件仅允许有限的权限。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       检查所有提交的变量。
      </simpara>
     </listitem>
    </itemizedlist>
    这是改进的脚本：
    <example>
     <title>更安全的文件名检查</title>
     <programlisting role="php">
<![CDATA[
<?php
// 从 PHP 用户有权访问的磁盘驱动器上删除一个文件。
$username = $_SERVER['REMOTE_USER']; // 使用认证机制
$userfile = basename($_POST['user_submitted_filename']);
$homedir  = "/home/$username";

$filepath = "$homedir/$userfile";

if (file_exists($filepath) && unlink($filepath)) {
    $logstring = "Deleted $filepath\n";
} else {
    $logstring = "Failed to delete $filepath\n";
}
$fp = fopen("/home/logging/filedelete.log", "a");
fwrite($fp, $logstring);
fclose($fp);

echo htmlentities($logstring, ENT_QUOTES);

?>
]]>
     </programlisting>
    </example>
    然而，这样做也是有缺陷的。如果认证系统允许用户创建自己的登录用户名，
    而用户选择 "../etc/" 作为登录名，系统将再次暴露。
    出于这个原因，宁愿编写更自定义的检查：
    <example>
     <title>更安全的文件名检查</title>
     <programlisting role="php">
<![CDATA[
<?php
$username     = $_SERVER['REMOTE_USER']; // 使用认证机制
$userfile     = $_POST['user_submitted_filename'];
$homedir      = "/home/$username";

$filepath     = "$homedir/$userfile";

if (!ctype_alnum($username) || !preg_match('/^(?:[a-z0-9_-]|\.(?!\.))+$/iD', $userfile)) {
    die("Bad username/filename");
}

//等等...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    根据操作系统的不同，需要关心各种各样的文件，包含设备条目（/dev/ 或 COM1）、配置文件（/etc/ 文件和 .ini 文件）、
    众所周知的文件存储区域（/home/， My Documents）等等。出于这个原因，创建一个禁止除明确允许之外所有内容的策略通常更容易。
   </para>
   <sect1 xml:id="security.filesystem.nullbytes">
    <title>Null 字节相关问题</title>
    <simpara>
     由于 <acronym>PHP</acronym> 使用底层 C 函数进行文件系统相关操作，因此它可能会以完全意想不到的方式处理 null 字节。
     由于 null 字节在 C 中表示字符串的结尾，包含 null 的字符串不会被完整的考虑，但是确切的说仅考虑出现在 null 字节之前的字符串。

     下面的示例程序展示了易受攻击的代码，演示了这个问题：
    </simpara>
    <example>
     <title>会被 null 字节攻击的代码</title>
     <programlisting role="php">
<![CDATA[
<?php
$file = $_GET['file']; // "../../etc/passwd\0"
if (file_exists('/home/wwwrun/'.$file.'.php')) {
    // 当 /home/wwwrun/../../etc/passwd 文件存在的时候 file_exists 将会返回 true
    include '/home/wwwrun/'.$file.'.php';
    // /etc/passwd 文件将会被包括在内
}
?>
]]>
     </programlisting>
    </example>
    <para>
     因此，在文件系统操作中都应该正确验证任何被污染的字符串。这是上个示例的更好版本：
    </para>
    <example>
     <title>正确验证输入</title>
     <programlisting role="php">
<![CDATA[
<?php
$file = $_GET['file']; 

// 可能的值列入白名单
switch ($file) {
    case 'main':
    case 'foo':
    case 'bar':
        include '/home/wwwrun/include/'.$file.'.php';
        break;
    default:
        include '/home/wwwrun/include/main.php';
}
?>
]]>
     </programlisting>
    </example>
   </sect1>

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
