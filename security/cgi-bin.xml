<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.3 $ -->
<!-- $Author: dallas $ -->
<!-- EN-Revision: 1.4 Maintainer: lm92 Status: ready -->
<chapter id="security.cgi-bin">
   <title>安装成 CGI 模式</title>

   <sect1 id="security.cgi-bin.attacks">
    <title>可能受到的攻击</title>
    <simpara>
     如果不想把 PHP 嵌入到服务器端软件（如 Apache）作为一个模块安装的话，您可以选择以
     <acronym>CGI</acronym> 的模式安装。或者把 PHP 用于不同的 CGI
     封装以便为代码创建安全的 chroot 和 setuid 环境。这种安装方式通常会把
     PHP 的可执行文件安装到 Web 服务器的 cgi-bin
     目录。CERT 建议书 <ulink url="&url.cert;">CA-96.11</ulink>
     建议不要把任何的解释器放到 cgi-bin 目录。尽管 PHP
     作为一个独立的解释器，但是它的设计使它可以防止这类型的攻击：
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       访问系统文件：<filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       在 URL 请求的问号（?）后面的信息会传给 CGI
       接口作为命名行的参数。其它的解释器会在命令行中打开并执行第一个参数所指定的文件。
      </simpara>
      <simpara>
       但是，以 CGI 模式安装的 PHP 解释器被调用时，它会拒绝解释这些参数。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       访问服务器上的任意目录：<filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
       好像上面这种情况，PHP 解释器所在目录后面的 URL 信息
       <filename role="uri">/secret/doc.html</filename> 将会例行地传给
       <acronym>CGI</acronym> 程序并进行解释。通常一些 Web
       服务器的会将它重定向到页面，如
       <filename role="uri">http://my.host/secret/script.php</filename>。如果是这样的话，某些服务器会先检查用户访问
       <filename role="uri">/secret</filename> 目录的权限，然后才会创建
       <filename role="uri">http://my.host/cgi-bin/php/secret/script.php</filename>
       上的页面重定向。不幸的是，很多服务器并没有检查用户访问
       /secret/script.php 的权限，只检查了
       <filename role="uri">/cgi-bin/php</filename> 的权限，这样任何能访问
       <filename role="uri">/cgi-bin/php</filename> 的用户就可以访问
       Web 目录下的任意文件了。
      </simpara>
      <simpara>
       在 PHP 里，编译时的可选项
       <link linkend="configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
       以及运行时的可选项 <link linkend="ini.doc-root">doc_root</link>和<link linkend="ini.user-dir">user_dir</link>都可以为服务器上的文件和目录添加限制，用于防止这类攻击。下面将对各个选项的设置进行详细讲解。
      </simpara>
     </listitem>
    </itemizedlist>
   </sect1>

   <sect1 id="security.cgi-bin.default">
    <title>方法一：Web 目录内的文件完全公开</title>

    <simpara>
     如果您的 Web 服务器不使用任何的密码或者IP地址对内容进行访问限制，您就不需要设置这些选项。如果您的
     Web 服务器不支持重定向，或者由于 Web 服务器不能和 PHP
     通信而使访问请求变得更为安全，您就可以在安装时添加
     <link linkend="configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
     选项。除此之外，您还要确认您的 PHP 程序不需要依靠其它方式调用，比如说直接通过
     <filename role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
     或通过重定向访问
     <filename role="php">http://my.host/dir/script.php</filename>。
    </simpara>
    <simpara>
     在Apache中，重定向可以使用AddHandler和Action语句来设置，请看下一节。
    </simpara>
   </sect1>

   <sect1 id="security.cgi-bin.force-redirect">
    <title>方法二：使用 --enable-force-cgi-redirect选项</title>
    <simpara>
     这个编译选项可以防止任何人通过如
     <filename role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>
     这样的 URL 直接调用 PHP。打开之后，PHP 只会遵守 Web 服务器的重定向规则进行解释。
    </simpara>
    <simpara>
     通常Apache中的重定向设置可以通过以下语句完成：
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
     这个选项只在 Apache 下进行过测试，并且要依赖于 Apache
     在重定向操作中所设置的非标准 CGI 环境变量
     <envar>REDIRECT_STATUS</envar>。如果您的 Web
     服务器不支持任何的方式对请求进行定向或重定向，您就不能使用这个选项，而应该用另一种方法，请看下一节。
    </simpara>
   </sect1>

   <sect1 id="security.cgi-bin.doc-root">
    <title>方法三：设置 doc_root 或 user_dir</title>
    <simpara>
     在 Web 服务器上放置可执行脚本和动态页面有时会产生一些安全问题。如果因为配置上的错误而导致脚本不能正常执行，那就会使源代码暴露，从而导致您的知识产权受侵害或者机密数据泄露。所以，很多系统管理员都会为
     PHP 代码设置一个只允许解释器访问的目录，这样的话，PHP
     解释器只对会解释代码而不会在配置错误时把源代码泄露。
    </simpara>
    <simpara>
     对于上一节提到的不支持重定向的情况，设置一个在 Web 目录外的
     doc_root 用于存放脚本也是一种解决方法。
    </simpara>
    <simpara>
     您可以通过<link linkend="configuration.file">配置文件
     </link>内的<link linkend="ini.doc-root">doc_root</link>
     或设置环境变量
     <envar>PHP_DOCUMENT_ROOT</envar> 来定义 PHP 脚本目录。如果您设置了该项，那么
     PHP 就只会解释 <parameter>doc_root</parameter>
     指定目录下的文件，并确保目录外的脚本不会被 PHP
     解释器执行（下面所说的 <parameter>user_dir</parameter> 除外）。
    </simpara>
    <simpara>
     另一个可用的选项就是
     <link linkend="ini.user-dir">user_dir</link>。当 user_dir
     没有设置的时候，<parameter>doc_root</parameter>
     就是唯一能控制在哪里打开文件选项。访问如
     <filename role="url">http://my.host/~user/doc.php</filename>
     这个 URL 时，并不会打开用户主目录下文件，而只会执行
     doc_root 指定目录下的
     <filename role="uri">~user/doc.php</filename>（这个子目录以[<literal>~</literal>]作开头）。
    </simpara>
    <simpara>
     如果 user_dir 被设置了，比如设成
     <filename role="dir">public_php</filename> 的话，那么像
     <filename role="url">http://my.host/~user/doc.php</filename>
     这样的请求将会执行用户主目录下的
     <filename role="dir">public_php/doc.php</filename>，假设用户主目录的绝对路径是
     <filename role="dir">/home/user</filename>，那么被执行文件将会是
     <filename>/home/user/public_php/doc.php</filename>。
    </simpara>
    <simpara>
     <parameter>user_dir</parameter> 的设置不受
     <parameter>doc_root</parameter>的影响，所以您可以把
     PHP 脚本的主目录和用户的目录分开管理。
    </simpara>
   </sect1>

   <sect1 id="security.cgi-bin.shell">
    <title>方法四：PHP 解释器放在 Web 目录以外</title>
    <para>
     一个非常安全的做法就是把 PHP 解释器放在 Web 目录外的地方，比如说
     <filename role="dir">/usr/local/bin</filename>。这样做有一个很不方便的地方就是你必须在每一个包含
     PHP 代码的文件的第一行加入如下语句：
     <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     你要使这些文件变成可执行文件。也就是说，您要像处理用
     Perl 或 sh 写的 CGI 脚本一样，使用以 <literal>#!</literal>
     开头的 shell-escape 机制来启动它们。
    </para>
    <para>
     在这种情况下，要使 PHP 能正确处理
     <envar>PATH_INFO</envar> 和 <envar>PATH_TRANSLATED</envar>
     等变量的话，您在编译 PHP 解释器时必须加入
     <link linkend="configure.enable-discard-path">--enable-discard-path</link> 参数。
    </para>
   </sect1>

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
