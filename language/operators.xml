<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 99ef98227f2d590d6124ebb4ebae0284a9d3e576 Maintainer: jhdxr Status: ready -->
<!-- CREDITS: mowangjuanzi -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>运算符</title>
  <simpara>
   运算符是可以通过给出的一或多个值（用编程行话来说，表达式）来产生另一个值（因而整个结构成为一个表达式）的东西。
  </simpara>
  <para>
   运算符可按照其能接受几个值来分组。一元运算符只能接受一个值，例如
   <literal>!</literal>（<link linkend="language.operators.logical">逻辑取反运算符</link>）或
   <literal>++</literal>（<link linkend="language.operators.increment">递增运算符</link>）。
   二元运算符可接受两个值，例如熟悉的<link
   linkend="language.operators.arithmetic">算术运算符</link>
   <literal>+</literal>（加）和 <literal>-</literal>（减），大多数 PHP
   运算符都是这种。最后是唯一的<link
   linkend="language.operators.comparison.ternary">三元运算符</link> <literal>? :</literal>，可接受三个值；通常就简单称之为“三元运算符”（尽管称之为条件运算符可能更合适）。
  </para>
  <para>
   PHP 的运算符完整列表见下节<link
   linkend="language.operators.precedence">运算符优先级</link>。该节也解释了运算符优先级和结合方向，这控制着在表达式包含有若干个不同运算符时究竟怎样对其求值。
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>运算符优先级</title>
   <para>
    运算符优先级指定了两个表达式绑定得有多“紧密”。例如，表达式 <literal>1 + 5 *
    3</literal> 的结果是 <literal>16</literal> 而不是 <literal>18</literal>
    是因为乘号（“*”）的优先级比加号（“+”）高。必要时可以用括号来强制改变优先级。例如：<literal>(1
    + 5) * 3</literal> 的值为 <literal>18</literal>。
   </para>
   <para>
    如果运算符优先级相同，那运算符的结合方向决定了该如何运算。例如，"-"是左联的，那么 <literal>1 - 2 - 3</literal> 就等同于 <literal>(1 - 2) - 3</literal>
    并且结果是 <literal>-4</literal>. 另外一方面，"="是右联的，所以 <literal>$a = $b = $c</literal> 等同于
    <literal>$a = ($b = $c)</literal>。
   </para>
   <para>
    没有结合的相同优先级的运算符不能连在一起使用，例如
    <literal>1 &lt; 2 &gt; 1</literal> 在PHP是不合法的。但另外一方面表达式
    <literal>1 &lt;= 1 == 1</literal> 是合法的, 因为 <literal>==</literal> 的优先级低于
    <literal>&lt;=</literal>。
   </para>
   <para>
    关联性仅对二（三）元操作符有意义。
    一元操作符是前缀或者后缀，所以不适用该概念。
    例如 <literal>!!$a</literal> 仅可分为 <literal>!(!$a)</literal>。
   </para>
   <para>
    括号的使用，哪怕在不是必要的场合下，通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。
   </para>
   <para>
    下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。
    <table>
     <title>运算符优先级</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>结合方向</entry>
        <entry>运算符</entry>
        <entry>附加信息</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>不适用</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry>
        <entry><link linkend="language.oop5.cloning">clone</link> 和 <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>右</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">算术运算符</link></entry>
       </row>
       <row>
        <entry>不适用</entry>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>++</literal>
         <literal>--</literal>
         <literal>~</literal>
         <literal>(int)</literal>
         <literal>(float)</literal>
         <literal>(string)</literal>
         <literal>(array)</literal>
         <literal>(object)</literal>
         <literal>(bool)</literal>
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">算术</link> (一元 <literal>+</literal> 和 <literal>-</literal>)，
         <link linkend="language.operators.increment">递增/递减</link>，
         <link linkend="language.operators.bitwise">按位</link>，
         <link linkend="language.types.typecasting">类型转换</link>&listendand;
         <link linkend="language.operators.errorcontrol">错误控制</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.operators.type">类型</link>
        </entry>
       </row>
       <row>
        <entry>不适用</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">算术运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">算数</link> (二元 <literal>+</literal> 和 <literal>-</literal>)，
         <link linkend="language.operators.array">array</link>&listendand;
         <link linkend="language.operators.string">string</link> （<literal>.</literal> PHP 8.0.0 前可用）
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         <literal>&lt;&lt;</literal>
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>.</literal></entry>
        <entry>
         <link linkend="language.operators.string">string</link> （PHP 8.0.0 起可用）
        </entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>
         <literal>&lt;</literal>
         <literal>&lt;=</literal>
         <literal>&gt;</literal>
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">比较运算符</link>
        </entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal>
         <literal>===</literal>
         <literal>!==</literal>
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">比较运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>&listendand;<link
         linkend="language.references">引用</link></entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>右</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.coalesce">null 合并运算符</link>
        </entry>
       </row>
       <row>
        <entry>无关联</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">三元运算符</link>
         (PHP 8.0.0 之前左联)
        </entry>
       </row>
       <row>
        <entry>右</entry>
        <entry>
         <literal>=</literal>
         <literal>+=</literal>
         <literal>-=</literal>
         <literal>*=</literal>
         <literal>**=</literal>
         <literal>/=</literal>
         <literal>.=</literal>
         <literal>%=</literal>
         <literal>&amp;=</literal>
         <literal>|=</literal>
         <literal>^=</literal>
         <literal>&lt;&lt;=</literal>
         <literal>&gt;&gt;=</literal>
         <literal>??=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">赋值运算符</link>
        </entry>
       </row>
       <row>
        <entry>不适用</entry>
        <entry><literal>yield from</literal></entry>
        <entry>
         <link linkend="control-structures.yield.from">yield from</link>
        </entry>
       </row>
       <row>
        <entry>不适用</entry>
        <entry><literal>yield</literal></entry>
        <entry>
         <link linkend="control-structures.yield">yield</link>
        </entry>
       </row>
       <row>
        <entry>不适用</entry>
        <entry><literal>print</literal></entry>
        <entry><function>print</function></entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>结合方向</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// PHP 的三元操作符跟 C/C++ 有区别
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (PHP 8.0.0 前可用)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    运算符优先级和关联方式仅决定表达式如何分组，不指定计算顺序。
    一般情况下， PHP 不指定表达式的计算顺序，并且代码避免指定假设执行顺序，
    因为行为会在 PHP 版本间发生变化或者依赖于旁边的代码。
    <example>
     <title>未定义执行顺序</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // 可能会输出 2 或 3

$i = 1;
$array[$i] = $i++; // 可能会设置索引 1 或 2
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>、<literal>-</literal> 、<literal>.</literal> 具有相同的优先级</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// 这行可能会导致不可预料的输出：
echo "x minus one equals " . $x-1 . ", or so I hope\n";
// 因为它是这样计算的：（PHP 8.0.0 之前版本）
echo (("x minus one equals " . $x) - 1) . ", or so I hope\n";
// 可以使用括号来强制指定优先级：
echo "x minus one equals " . ($x-1) . ", or so I hope\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, or so I hope
-1, or so I hope
x minus one equals 3, or so I hope
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     尽管 <literal>=</literal> 比其它大多数的运算符的优先级低，PHP
     仍旧允许类似如下的表达式：<literal>if (!$a = foo())</literal>，在此例中
     <literal>foo()</literal> 的返回值被赋给了 <varname>$a</varname>。
    </para>
   </note>
   <sect2 role="changelog">
    &reftitle.changelog;
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>8.0.0</entry>
        <entry>
         现在，字符串连接符（<literal>.</literal>）的优先级比算数加/减（<literal>+</literal> 和 
         <literal>-</literal>）、按位左/右移（<literal>&lt;&lt;</literal> 和 
         <literal>&gt;&gt;</literal>）更低。在此之前，它的优先级与 <literal>+</literal>、
         <literal>-</literal> 相同，并且比 <literal>&lt;&lt;</literal>、 
         <literal>&gt;&gt;</literal> 更高。
        </entry>
       </row>
       <row>
        <entry>8.0.0</entry>
        <entry>
         三元运算符（<literal>? :</literal>）是现在是非关联的；以前它是左联的。
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         已弃用在无括号的表达式中依赖字符串连接（<literal>.</literal>）相对于算数加/减（<literal>+</literal> 或者
          <literal>-</literal>）或者按位左/右移（<literal>&lt;&lt;</literal> 或者 
          <literal>&gt;&gt;</literal>）的优先级的使用方法。
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         不推荐使用三元运算符（<literal>? :</literal>）的左联。
         即已弃用嵌套多个未带括号的三元运算符。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>算术运算符</title>
   <simpara>
    还记得学校里学到的基本数学知识吗？就和它们一样。
   </simpara>
   <table>
    <title>算术运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>标识</entry>
       <entry>
        根据情况将 <varname>$a</varname> 转化为 <type>int</type> 或
        <type>float</type>。
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>取反</entry>
       <entry><varname>$a</varname> 的负值。</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>加法</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的和。</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>减法</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的差。</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乘法</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的积。</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>除法</entry>
       <entry><varname>$a</varname> 除以 <varname>$b</varname> 的商。</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>取模</entry>
       <entry><varname>$a</varname> 除以 <varname>$b</varname> 的余数。</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>求幂</entry>
       <entry> <varname>$a</varname> 的 <varname>$b</varname>次方的值。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    除法运算符总是返回浮点数。只有在下列情况例外：两个操作数都是整数（或字符串转换成的整数）并且正好能整除，这时它返回一个整数。
    整数除法可参考 <function>intdiv</function>。
   </simpara>
   <simpara>
    取模运算符的操作数在运算之前都会转换成 <type>int</type> 。 浮点数取模可参考
    <function>fmod</function>。
   </simpara>
   <para>
    取模运算符 <literal>%</literal> 的结果和被除数的符号（正负号）相同。即
    <literal>$a % $b</literal> 的结果和 <varname>$a</varname> 的符号相同。例如：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // 打印 2
echo (5 % -3)."\n";          // 打印 2
echo (-5 % 3)."\n";          // 打印 -2
echo (-5 % -3)."\n";         // 打印 -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.math">数学函数</link></member>
     </simplelist>
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>赋值运算符</title>
   <simpara>
    基本的赋值运算符是“=”。一开始可能会以为它是“等于”，其实不是的。它实际上意味着把右边表达式的值赋给左边的运算数。
   </simpara>
   <para>
    赋值运算表达式的值也就是所赋的值。也就是说，“<literal>$a = 3</literal>”的值是 3。这样就可以做一些小技巧：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a 现在成了 9，而 $b 成了 4。

?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    在基本赋值运算符之外，还有适合于所有<link
    linkend="language.operators">二元算术</link>，数组集合和字符串运算符的“组合运算符”，这样可以在一个表达式中使用它的值并把表达式的结果赋给它，例如：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // 设置 $a 为 8 ，之前说过： $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // 设置 $b 为 "Hello There!"，就像 $b = $b . "There!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    注意赋值运算将原变量的值拷贝到新变量中（传值赋值），所以改变其中一个并不影响另一个。这也适合于在密集循环中拷贝一些值例如大数组。
   </para>
   <para>
    在 PHP 中普通的传值赋值行为有个例外就是碰到对象 <type>object</type> 时，在
    PHP 5 中是以引用赋值的，除非明确使用了 <link
    linkend="language.oop5.cloning">clone</link> 关键字来拷贝。
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>引用赋值</title>
    <para>
     PHP 支持引用赋值，使用“<computeroutput>$var
     = &amp;$othervar;</computeroutput>”语法。引用赋值意味着两个变量指向了同一个数据，没有拷贝任何东西。
    </para>
    <para>
     <example>
      <title>引用赋值</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b 是 $a 的引用

print "$a\n"; // 输出 3
print "$b\n"; // 输出 3

$a = 4; // 修改 $a

print "$a\n"; // 输出 4
print "$b\n"; // 也输出 4，因为 $b 是 $a 的引用，因此也被改变
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <link linkend="language.oop5.basic.new">new</link>
     运算符自动返回一个引用，因此对
     <link linkend="language.oop5.basic.new">new</link> 的结果进行引用赋值是错误的。
    </para>
    <para>
     <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     有关引用更多信息参见本手册中 <link
     linkend="language.references">引用的解释</link> 一章。
    </para>
   </sect2>


   <sect2 xml:id="language.operators.assignment.arithmetic">
    <title>算术赋值运算符</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>例子</entry>
        <entry>等同于</entry>
        <entry>操作</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a += $b</entry>
        <entry>$a = $a + $b</entry>
        <entry>加法</entry>
       </row>
       <row>
        <entry>$a -= $b</entry>
        <entry>$a = $a - $b</entry>
        <entry>减法</entry>
       </row>
       <row>
        <entry>$a *= $b</entry>
        <entry>$a = $a * $b</entry>
        <entry>乘法</entry>
       </row>
       <row>
        <entry>$a /= $b</entry>
        <entry>$a = $a / $b</entry>
        <entry>除法</entry>
       </row>
       <row>
        <entry>$a %= $b</entry>
        <entry>$a = $a % $b</entry>
        <entry>取模</entry>
       </row>
       <row>
        <entry>$a **= $b</entry>
        <entry>$a = $a ** $b</entry>
        <entry>指数</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.bitwise">
    <title>位赋值运算符</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>例子</entry>
        <entry>等同于</entry>
        <entry>操作</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp;= $b</entry>
        <entry>$a = $a &amp; $b</entry>
        <entry>按位与</entry>
       </row>
       <row>
        <entry>$a |= $b</entry>
        <entry>$a = $a | $b</entry>
        <entry>按位或</entry>
       </row>
       <row>
        <entry>$a ^= $b</entry>
        <entry>$a = $a ^ $b</entry>
        <entry>按位异或</entry>
       </row>
       <row>
        <entry>$a &lt;&lt;= $b</entry>
        <entry>$a = $a &lt;&lt; $b</entry>
        <entry>左移</entry>
       </row>
       <row>
        <entry>$a &gt;&gt;= $b</entry>
        <entry>$a = $a &gt;&gt; $b</entry>
        <entry>右移</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.other">
    <title>其他赋值运算符</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>例子</entry>
        <entry>等同于</entry>
        <entry>操作</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a .= $b</entry>
        <entry>$a = $a . $b</entry>
        <entry>字符串拼接</entry>
       </row>
       <row>
        <entry>$a ??= $b</entry>
        <entry>$a = $a ?? $b</entry>
        <entry>NULL 合并</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.operators.arithmetic">算术运算符</link></member>
      <member><link linkend="language.operators.bitwise">位运算符</link></member>
      <member><link linkend="language.operators.comparison.coalesce">NULL 合并运算符</link></member>
     </simplelist>
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>位运算符</title>
   <simpara>
    位运算符允许对整型数中指定的位进行求值和操作。
   </simpara>

   <table>
    <title>位运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>And（按位与）</entry>
       <entry>将把 <varname>$a</varname> 和 <varname>$b</varname> 中都为 1 的位设为 1。</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Or（按位或）</entry>
       <entry>将把 <varname>$a</varname> 和 <varname>$b</varname> 中任何一个为 1 的位设为 1。</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Xor（按位异或）</entry>
       <entry>将把 <varname>$a</varname> 和 <varname>$b</varname> 中一个为 1 另一个为 0 的位设为 1。</entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Not（按位取反）</entry>
       <entry>将 <varname>$a</varname> 中为 0 的位设为 1，反之亦然。</entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Shift left（左移）</entry>
       <entry>将 <varname>$a</varname> 中的位向左移动 <varname>$b</varname> 次（每一次移动都表示“乘以 2”）。</entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Shift right（右移）</entry>
       <entry>将 <varname>$a</varname> 中的位向右移动 <varname>$b</varname> 次（每一次移动都表示“除以 2”）。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    位移在 PHP 中是数学运算。向任何方向移出去的位都被丢弃。左移时右侧以零填充，符号位被移走意味着正负号不被保留。右移时左侧以符号位填充，意味着正负号被保留。
   </para>
   <para>
    要用括号确保想要的<link linkend="language.operators.precedence">优先级</link>。例如
    <literal>$a &amp; $b == true</literal> 先进行比较再进行按位与；而
    <literal>($a &amp; $b) == true</literal> 则先进行按位与再进行比较。
   </para>
   <para>
    如果 <literal>&amp;</literal>、 <literal>|</literal> 和
    <literal>^</literal> 运算符的左右两个操作对象都是字符串，将对会组成字符串的字符 
    ASCII 值执行操作，结果也是一个字符串。除此之外，两个操作对象都将 
    <link linkend="language.types.integer.casting">转换为整数</link> ，结果也将会是整数。
   </para>
   <para>
    如果 <literal>~</literal> 运算符的操作对象是字符串，则将对组成字符串的字符 ASCII 值进行操作，
    结果将会是字符串，否则操作对象和结构都会是整数。
   </para>
   <para>
    <literal>&lt;&lt;</literal> 和 <literal>&gt;&gt;</literal> 运算符的操作对象和结果始终都是整数。
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
PHP 的 ini 设定 error_reporting 使用了按位的值，
提供了关闭某个位的真实例子。要显示除了提示级别
之外的所有错误，php.ini 中是这样用的：
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
具体运作方式是先取得 E_ALL 的值：
<computeroutput>00000000000000000111011111111111</computeroutput>
再取得 E_NOTICE 的值：
<computeroutput>00000000000000000000000000001000</computeroutput>
然后通过 <literal>~</literal> 将其取反：
<computeroutput>11111111111111111111111111110111</computeroutput>
最后再用按位与 AND（&amp;）得到两个值中都设定了（为 1）的位：
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
另外一个方法是用按位异或 XOR（<literal>^</literal>）来取得只在
其中一个值中设定了的位：
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting 也可用来演示怎样置位。只显示错误和可恢复
错误的方法是：
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
也就是将 E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
和 E_RECOVERABLE_ERROR
<computeroutput>00000000000000000001000000000000</computeroutput>
用按位或 OR（<literal>|</literal>）运算符来取得在任何一个值中被置位的结果：
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>整数的 AND，OR 和 XOR 位运算符</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * 忽略顶部，
 * 它只是为了使输出更加清晰而格式化。
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * 这是示例。
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>字符串的 XOR 运算符</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // 输出 '5'

echo "12" ^ "9"; // 输出退格字符 (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // 输出 ascii 值 #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // 输出 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // 输出 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>整数的位移</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * 这是示例。
 */

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'sign bits get shifted out');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side');


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


/*
 * 忽略顶部，
 * 它只是为了使输出更加清晰而格式化。
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binary:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTE: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     使用 <link linkend="book.gmp">gmp</link> 扩展对超出 <literal>PHP_INT_MAX</literal> 的数值来进行位操作。
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
      <member><function>pack</function></member>
      <member><function>unpack</function></member>
      <member><function>gmp_and</function></member>
      <member><function>gmp_or</function></member>
      <member><function>gmp_xor</function></member>
      <member><function>gmp_testbit</function></member>
      <member><function>gmp_clrbit</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>比较运算符</title>
   <simpara>
    比较运算符，如同它们名称所暗示的，允许对两个值进行比较。还可以参考
    <link linkend="types.comparisons">PHP 类型比较表</link>看不同类型相互比较的例子。
   </simpara>
   <table>
    <title>比较运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等于</entry>
       <entry>&true;，如果类型转换后 <varname>$a</varname> 等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>全等</entry>
       <entry>&true;，如果 <varname>$a</varname> 等于 <varname>$b</varname>，并且它们的类型也相同。</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>不等</entry>
       <entry>&true;，如果类型转换后 <varname>$a</varname> 不等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>不等</entry>
       <entry>&true;，如果类型转换后 <varname>$a</varname> 不等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>不全等</entry>
       <entry>&true;，如果 <varname>$a</varname> 不等于 <varname>$b</varname>，或者它们的类型不同。</entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>小与</entry>
       <entry>&true;，如果 <varname>$a</varname> 严格小于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>大于</entry>
       <entry>&true;，如果 <varname>$a</varname> 严格大于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>小于等于</entry>
       <entry>&true;，如果 <varname>$a</varname> 小于或者等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>大于等于</entry>
       <entry>&true;，如果 <varname>$a</varname> 大于或者等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>太空船运算符（组合比较符）</entry>
       <entry>
        当<varname>$a</varname>小于、等于、大于 <varname>$b</varname>时
        分别返回一个小于、等于、大于0的 <type>int</type> 值。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    当两个操作对象都是
    <link linkend="language.types.numeric-strings">数字字符串</link>，
    或一个是数字另一个是
    <link linkend="language.types.numeric-strings">数字字符串</link>，
    就会自动按照数值进行比较。
    此规则也适用于
    <link linkend="control-structures.switch">switch</link> 语句。
    当比较时用的是 <literal>===</literal> 或 <literal>!==</literal>，
    则不会进行类型转换——因为不仅要对比数值，还要对比类型。
   </para>
   <warning>
   <para>
   PHP 8.0.0 之前，如果 <type>string</type> 与数字或者数字字符串进行比较，
   则在比较前会将 <type>string</type> 转化为数字。
   在如下示例中会出现不可预料的结果：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
      </programlisting>
      &example.outputs.7;
      <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
      </screen>
      &example.outputs.8;
      <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]>
      </screen>   
     </informalexample>
    </para>
   </warning>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// 整数
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// 浮点数
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// 字符串
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// 数组
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// 对象
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// 不仅仅比较值，而且也会匹配键
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1

?>
]]>

     </programlisting>
    </informalexample>
   </para>

   <para>
    对于多种类型，比较运算符根据下表比较（按顺序）。
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>比较多种类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>运算数 1 类型</entry>
       <entry>运算数 2 类型</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> 或 <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>将 &null; 转换为 ""，进行数字或词汇比较</entry>
      </row>
      <row>
       <entry><type>bool</type> 或 <type>null</type></entry>
       <entry>任何其它类型</entry>
       <entry>转换为 <type>bool</type>，&false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>
        内置类可以定义自己的比较，不同类不能比较，相同的类查看<link
        linkend="language.oop5.object-comparison">对象比较</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>、<type>resource</type>、<type>int</type>、<type>float</type></entry>
       <entry><type>string</type>、<type>resource</type>、<type>int</type>、<type>float</type></entry>
       <entry>将字符串和资源转换成数字，按普通数学比较</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>
        成员越少的数组越小，如果运算数 1 中的键不存在于运算数
        2 中则数组无法比较，否则挨个值比较（见下例）
       </entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>任何其它类型</entry>
       <entry><type>object</type> 总是更大</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>任何其它类型</entry>
       <entry><type>array</type> 总是更大</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <example>
     <title>Boolean/null comparison</title>
     <programlisting role="php">
<![CDATA[
<?php
// Bool 和 null 总是作为 bool 比较
var_dump(1 == TRUE);  // TRUE - same as (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - same as (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - same as (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - same as (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 is FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    <example>
     <title>标准数组比较代码</title>
     <programlisting role="php">
<![CDATA[
<?php
// 数组是用标准比较运算符或者太空船运算符进行比较的
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return 1;
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <warning>
    <title>比较浮点数</title>

    <para>
     由于浮点数 <type>float</type> 的内部表达方式，不应比较两个浮点数<type>float</type>是否相等。
    </para>

    <para>
     更多信息参见 <type>float</type>。
    </para>
   </warning>

   <note>
    <simpara>
     请注意，在比较不同类型的值时，类型转换并不总是很明显，尤其是比较 &integer; 与 &boolean; 或者
     &integer; 与 &string;。因此，在大多数情况下，通常建议使用 <literal>===</literal> 和
     <literal>!==</literal> 进行比较而不是 <literal>==</literal> 和 <literal>!=</literal>。
    </simpara>
   </note>

   <sect2 xml:id="language.operators.comparison.incomparable">
    <title>不能比较的值</title>
    <simpara>
     虽然恒等比较（<literal>===</literal> 和
     <literal>!==</literal>）可以应用于任意值，其它比较运算符应该仅用于可比较的值。不能比较的值的比较的结果是不确定的，不应依赖。
    </simpara>
   </sect2>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>strcasecmp</function></member>
      <member><function>strcmp</function></member>
      <member><link linkend="language.operators.array">数组运算符</link></member>
      <member><link linkend="language.types">类型</link></member>
     </simplelist>
    </para>
   </sect2>

  <sect2 xml:id="language.operators.comparison.ternary">
    <title>三元运算符</title>
    <para>
     另一个条件运算符是“?:”（或三元）运算符 。
     <example>
      <title>赋默认值</title>
      <programlisting role="php">
<![CDATA[
<?php
// 三元运算符的例子
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// 以上等同于以下的  if/else 语句
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
      </programlisting>
     </example>
     表达式 <literal>(expr1) ? (expr2) : (expr3)</literal> 在
     <replaceable>expr1</replaceable> 求值为 &true;
     时的值为 <replaceable>expr2</replaceable>，在
     <replaceable>expr1</replaceable> 求值为 &false; 时的值为
     <replaceable>expr3</replaceable>。
    </para>
    <para>
     可以省略三元运算符中间那部分。表达式
     <literal>expr1 ?: expr3</literal> 等同于如果
     <replaceable>expr1</replaceable> 求值为 &true; 时返回
     <replaceable>expr1</replaceable> 的结果，否则返回
     <replaceable>expr3</replaceable>。<replaceable>expr1</replaceable> 在这里仅执行一次。
    </para>
    <note>
     <simpara>
      注意三元运算符是个语句，因此其求值不是变量，而是语句的结果。如果想通过引用返回一个变量这点就很重要。在一个通过引用返回的函数中语句
      <literal>return $var == 42 ? $a : $b;</literal> 将不起作用，以后的 PHP
      版本会为此发出一条警告。
     </simpara>
    </note>
    <note>
     <para>
      建议避免将三元运算符堆积在一起使用。和其他语言相比，
      当在单个表达式中使用多个未加括号的三元运算符时会造成
      PHP 运算结果不清晰。
      甚至在 PHP 8.0.0 之前，三元运算符是从左到右执行的，
      而大多数其他编程语言是从右到左的。
      自 PHP 7.4.0 起，弃用依靠左联。
      PHP 8.0.0 起，三元运算符是非关联的。
      <example>
       <title>不清晰的三元运算符行为</title>
       <programlisting role="php">
<![CDATA[
<?php
// 乍看起来下面的输出是 'true'
echo (true ? 'true' : false ? 't' : 'f');

// 然而，上面语句的实际输出是't'，因为在 PHP 8.0.0 之前三元运算符是左联的

// 下面是与上面等价的语句，但更清晰
echo ((true ? 'true' : 'false') ? 't' : 'f');

// 这里可以看到第一个表达式的计算结果是 “true”，第二个表达式的计算结果为 (bool)true，
// 因此返回第二个三元表达式的 true 分支。
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <note>
     <para>
      然而，短三元运算符（<literal>?:</literal>）的链接是稳定且合理的。他将第一个参数进行求值，结果为非假值。注意，未定义的值将会引发警告。
      <example>
       <title>Short-ternary chaining</title>
       <programlisting role="php">
<![CDATA[
<?php
echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; //1
echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; //2
echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; //3
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>NULL 合并运算符</title>
    <para>
     另一个简略运算符是 "??" （NULL 合并）运算符。
     <example>
      <title>设置默认值</title>
      <programlisting role="php">
<![CDATA[
<?php
// NULL 合并运算符的例子
$action = $_POST['action'] ?? 'default';

// 以上例子等同于于以下 if/else 语句
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}
?>
]]>
      </programlisting>
     </example>
     当 <replaceable>expr1</replaceable> 为  &null;，表达式 <literal>(expr1) ?? (expr2)</literal> 等同于
     <replaceable>expr2</replaceable>，否则为 <replaceable>expr1</replaceable>。
    </para>
    <para>
     尤其要注意，当不存在左侧的值时，此运算符也和 <function>isset</function> 一样不会产生警告。
     对于 array 键尤其有用。
    </para>
    <note>
     <simpara>
      请注意：NULL 合并运算符是一个表达式，产生的也是表达式结果，而不是变量。
      返回引用变量时需要强调这一点。
      因此，在返回引用的函数里就无法使用这样的语句：<literal>return $foo ?? $bar;</literal>，还会提示警告。
     </simpara>
    </note>
    <note>
     <para>
      null 合并运算符的优先级较低。这意味着如果将它与其它运算符（比如字符串链接或者算术运算符）混合使用，可能需要括号。
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// $name 未定义，引发警告。
print 'Mr. ' . $name ?? 'Anonymous';

// 打印 "Mr. Anonymous"
print 'Mr. ' . ($name ?? 'Anonymous');
?>
]]>
     </programlisting>
    </note>
    <note>
     <para>
      请注意，NULL 合并运算符支持简单的嵌套：
      <example>
       <title>嵌套 NULL 合并运算符</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // 输出 1

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>错误控制运算符</title>
   <simpara>
    PHP 支持一个错误控制运算符：<literal>@</literal>。当将其放置在一个 PHP
    表达式之前，该表达式可能产生的任何错误诊断都被抑制。
   </simpara>
   <para>
    如果用 <function>set_error_handler</function>
    设定了自定义的错误处理函数，即使诊断信息被抑制，也仍然会被调用。
   </para>

   <warning>
    <para>
     PHP 8.0.0 之前，如果错误被 <literal>@</literal> 运算符抑制，则在自定义错误处理程序中调用 <function>error_reporting</function> 将始终返回
     <literal>0</literal>。PHP 8.0.0 起，返回值为 <literal>E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_RECOVERABLE_ERROR | E_PARSE</literal>。
    </para>
   </warning>

   <simpara>
    <function>error_get_last</function> 返回数组中的 <literal>"message"</literal> 元素储存了表达式产生的任意错误信息。
    此函数的返回结果会随着每次错误的发生而相应变化，所以需要尽早检查。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* 故意文件错误 */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '" . error_get_last()['message'] . "'");

// 这适用于所有表达式，而不仅仅是函数：
$value = @$cache[$key];
// 如果索引 $key 不存在，则不会发出通知。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     <literal>@</literal> 运算符只对 <link linkend="language.expressions">表达式</link> 有效。
     对新手来说一个简单的规则就是：如果能从某处获得值，就能在它前面加上
     <literal>@</literal> 运算符。例如，可以把它放在变量，函数调用，某些语言构造调用（例如 <function>include</function> ）等等之前。
     不能把它放在函数或类的定义之前，也不能用于条件结构例如 <literal>if</literal> 和 &foreach; 等。
    </simpara>
   </note>
   <warning>
    <para>
     PHP 8.0.0 之前，<literal>@</literal> 运算符会禁用导致脚本停止运行的严重错误。
     例如在调用一个不存在的函数前添加 <literal>@</literal>，由于函数不可用或者输入错误，
     将会导致脚本终止，而不会说明原因。
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>error_reporting</function></member>
      <member><link linkend="ref.errorfunc">错误处理与日志记录函数</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>执行运算符</title>
   <para>
    PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP
    将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数
    <function>shell_exec</function> 相同。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     关闭了 <function>shell_exec</function> 时反引号运算符是无效的。
    </para>
   </note>
   <note>
    <para>
     与其它某些语言不同，反引号不能在双引号字符串中使用。
    </para>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.exec">程序执行函数</link></member>
      <member><function>popen</function></member>
      <member><function>proc_open</function></member>
      <member><link linkend="features.commandline">PHP 的命令行模式</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>递增／递减运算符</title>
   <para>
    PHP 支持 C 风格的前／后递增与递减运算符。
   </para>
   <note>
    <simpara>
     递增／递减运算符不影响布尔值。递减
     &null; 值也没有效果，但是递增 &null; 的结果是 <literal>1</literal>。
    </simpara>
   </note>
   <table>
    <title>递增／递减运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>效果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前加</entry>
       <entry><varname>$a</varname> 的值加一，然后返回 <varname>$a</varname>。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>后加</entry>
       <entry>返回 <varname>$a</varname>，然后将 <varname>$a</varname> 的值加一。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前减</entry>
       <entry><varname>$a</varname> 的值减一， 然后返回 <varname>$a</varname>。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>后减</entry>
       <entry>返回 <varname>$a</varname>，然后将 <varname>$a</varname> 的值减一。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    一个简单的示例脚本：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Postdecrement</h3>";
$a = 5;
echo "Should be 5: " . $a-- . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";

echo "<h3>Predecrement</h3>";
$a = 5;
echo "Should be 4: " . --$a . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在
    Perl 中 <literal>$a = 'Z'; $a++;</literal> 将把 <literal>$a</literal>
    变成<literal>'AA'</literal>，而在 C 中，<literal>a = 'Z'; a++;</literal> 将把
    <literal>a</literal> 变成 <literal>'['</literal>（<literal>'Z'</literal>
    的 ASCII 值是 90，<literal>'['</literal> 的 ASCII 值是
    91）。注意字符变量只能递增，不能递减，并且只支持纯 ASCII 字母数字（a-z、A-Z 和
    0-9）。递增/递减其他字符变量则无效，原字符串没有变化。
    <example>
     <title>涉及字符变量的算数运算</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Alphabetic strings ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// 字母数字字符串的不同行为
echo '== Alphanumeric strings ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Alphabetic strings ==
X
Y
Z
AA
AB
AC
== Alphanumeric strings ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    递增或递减布尔值没有效果。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>逻辑运算符</title>

   <table>
    <title>逻辑运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And（逻辑与）</entry>
       <entry>&true;，如果 <varname>$a</varname> 和 <varname>$b</varname> 都为 &true;。</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or（逻辑或）</entry>
       <entry>&true;，如果 <varname>$a</varname> 或 <varname>$b</varname> 任一为 &true;。</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor（逻辑异或）</entry>
       <entry>&true;，如果 <varname>$a</varname> 或 <varname>$b</varname> 任一为 &true;，但不同时是。</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not（逻辑非）</entry>
       <entry>&true;，如果 <varname>$a</varname> 不为 &true;。</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And（逻辑与）</entry>
       <entry>&true;，如果 <varname>$a</varname> 和 <varname>$b</varname> 都为 &true;。</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or（逻辑或）</entry>
       <entry>&true;，如果 <varname>$a</varname> 或 <varname>$b</varname> 任一为 &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    “与”和“或”有两种不同形式运算符的原因是它们运算的优先级不同（见<link linkend="language.operators.precedence">运算符优先级</link>）。
   </simpara>
   <example>
    <title>逻辑运算符示例</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() 根本没机会被调用，被运算符“短路”了

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" 比 "or" 的优先级高

// 表达式 (false || true) 的结果被赋给 $e
// 等同于：($e = (false || true))
$e = false || true;

// 常量 false 被赋给 $f，true 被忽略
// 等同于：(($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" 比 "and" 的优先级高

// 表达式 (true && false) 的结果被赋给 $g
// 等同于：($g = (true && false))
$g = true && false;

// 常量 true 被赋给 $h，false 被忽略
// 等同于：(($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>字符串运算符</title>
   <simpara>
    有两个字符串（<type>string</type>）运算符。第一个是连接运算符（“.”），它返回其左右参数连接后的字符串。第二个是连接赋值运算符（“<literal>.=</literal>”），它将右边参数附加到左边的参数之后。更多信息见<link
    linkend="language.operators.assignment">赋值运算符</link>。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // 现在 $b 包含 "Hello World!"

$a = "Hello ";
$a .= "World!";     // 现在 $a 包含 "Hello World!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.string">字符串类型</link></member>
      <member><link linkend="ref.strings">字符串函数</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>数组运算符</title>
   <table>
    <title>数组运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>联合</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的联合。</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>相等</entry>
       <entry>如果 <varname>$a</varname> 和 <varname>$b</varname> 具有相同的键／值对则为 &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>全等</entry>
       <entry>如果 <varname>$a</varname> 和 <varname>$b</varname> 具有相同的键／值对并且顺序和类型都相同则为 &true;。</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>不等</entry>
       <entry>如果 <varname>$a</varname> 不等于 <varname>$b</varname> 则为 &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>不等</entry>
       <entry>如果 <varname>$a</varname> 不等于 <varname>$b</varname> 则为 &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>不全等</entry>
       <entry>如果 <varname>$a</varname> 不全等于 <varname>$b</varname> 则为 &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <literal>+</literal> 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // $a 和 $b 的并集
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // $b 和 $a 的并集
echo "Union of \$b and \$a: \n";
var_dump($c);

$a += $b; //  $a += $b 的并集是 $a 和 $b
echo "Union of \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    执行后，此脚本会显示：
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
Union of $a += $b:
array(3) {
  'a' =>
  string(5) "apple"
  'b' =>
  string(6) "banana"
  'c' =>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    数组中的单元如果具有相同的键名和值则比较时相等。
   </para>
   <para>
    <example>
     <title>比较数组</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.array">数组类型</link></member>
      <member><link linkend="ref.array">数组函数</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>类型运算符</title>
   <para>
    <literal>instanceof</literal> 用于确定一个 PHP 变量是否属于某一类
    <link linkend="language.oop5.basic.class">class</link> 的实例：
    <example>
     <title>对类使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal>　也可用来确定一个变量是不是继承自某一父类的子类的实例：
    <example>
     <title>对继承类使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    检查一个对象是否<emphasis>不是</emphasis>某个类的实例，可以使用<link
    linkend="language.operators.logical">逻辑运算符 <literal>not</literal></link>。
    <example>
     <title>使用 <literal>instanceof</literal> 检查对象<emphasis>不是</emphasis>某个类的实例</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    最后，<literal>instanceof</literal>也可用于确定一个变量是不是实现了某个<link
    linkend="language.oop5.interfaces">接口</link>的对象的实例:
    <example>
     <title>对接口使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    虽然 <literal>instanceof</literal> 通常直接与类名一起使用，但也可以使用对象或字符串变量：
    <example>
     <title>对其它变量使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b 是 MyClass 类的对象
var_dump($a instanceof $c); // $c 是字符串 'MyClass'
var_dump($a instanceof $d); // $d 是字符串 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回
    &false;。PHP 7.3.0 之前不允许用于检测常量。
    <example>
     <title>用 <literal>instanceof</literal> 检测其它变量</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a 是整数
var_dump($b instanceof stdClass); // $b 是 NULL
var_dump($c instanceof stdClass); // $c 是资源
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para><para>
    PHP 7.3.0 起，
    <literal>instanceof</literal> 操作符的左侧可以放常量。
    <example>
     <title>使用 <literal>instanceof</literal> 测试常量</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    PHP 8.0.0 起， <literal>instanceof</literal> 可以与任何表达式一起使用。表达式必须使用括号括起来并且生成
    <type>string</type>。
    <!-- RFC: https://wiki.php.net/rfc/variable_syntax_tweaks -->
    <example>
     <title>将 <literal>instanceof</literal> 与任意表达式一起使用</title>
     <programlisting role="php">
      <![CDATA[
<?php

class ClassA extends \stdClass {}
class ClassB extends \stdClass {}
class ClassC extends ClassB {}
class ClassD extends ClassA {}

function getSomeClass(): string
{
    return ClassA::class;
}

var_dump(new ClassA instanceof ('std' . 'Class'));
var_dump(new ClassB instanceof ('Class' . 'B'));
var_dump(new ClassC instanceof ('Class' . 'A'));
var_dump(new ClassD instanceof (getSomeClass()));
?>
]]>
     </programlisting>
     &example.outputs.8;
     <screen>
      <![CDATA[
bool(true)
bool(true)
bool(false)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    <literal>instanceof</literal> 在功能上有个
    类似的变体 <function>is_a</function>。
   </simpara>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>get_class</function></member>
      <member><function>is_a</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
