<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a8b24da312bc04d20f404f99c90d2705e850ec16 Maintainer: jhdxr Status: ready -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>运算符</title>
  <simpara>
   运算符是可以通过给出的一或多个值（用编程行话来说，表达式）来产生另一个值（因而整个结构成为一个表达式）的东西。
  </simpara>
  <para>
   运算符可按照其能接受几个值来分组。一元运算符只能接受一个值，例如
   <literal>!</literal>（<link linkend="language.operators.logical">逻辑取反运算符</link>）或
   <literal>++</literal>（<link linkend="language.operators.increment">递增运算符</link>）。
   二元运算符可接受两个值，例如熟悉的<link
   linkend="language.operators.arithmetic">算术运算符</link>
   <literal>+</literal>（加）和 <literal>-</literal>（减），大多数 PHP
   运算符都是这种。最后是唯一的<link
   linkend="language.operators.comparison.ternary">三元运算符</link> <literal>? :</literal>，可接受三个值；通常就简单称之为“三元运算符”（尽管称之为条件运算符可能更合适）。
  </para>
  <para>
   PHP 的运算符完整列表见下节<link
   linkend="language.operators.precedence">运算符优先级</link>。该节也解释了运算符优先级和结合方向，这控制着在表达式包含有若干个不同运算符时究竟怎样对其求值。
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>运算符优先级</title>
   <para>
    运算符优先级指定了两个表达式绑定得有多“紧密”。例如，表达式 <literal>1 + 5 *
    3</literal> 的结果是 <literal>16</literal> 而不是 <literal>18</literal>
    是因为乘号（“*”）的优先级比加号（“+”）高。必要时可以用括号来强制改变优先级。例如：<literal>(1
    + 5) * 3</literal> 的值为 <literal>18</literal>。
   </para>
   <para>
    如果运算符优先级相同，那运算符的结合方向决定了该如何运算。例如，"-"是左联的，那么 <literal>1 - 2 - 3</literal> 就等同于 <literal>(1 - 2) - 3</literal>
    并且结果是 <literal>-4</literal>. 另外一方面，"="是右联的，所以 <literal>$a = $b = $c</literal> 等同于
    <literal>$a = ($b = $c)</literal>。
   </para>
   <para>
    没有结合的相同优先级的运算符不能连在一起使用，例如 <literal>1 &lt; 2 &gt; 1</literal> 在PHP是不合法的。但另外一方面表达式 <literal>1 &lt;= 1 == 1</literal> 是合法的, 因为 <literal>==</literal> 的优先级低于 <literal>&lt;=</literal>。
   </para>
   <para>
    括号的使用，哪怕在不是必要的场合下，通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。
   </para>
   <para>
    下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。
    <table>
     <title>运算符优先级</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>结合方向</entry>
        <entry>运算符</entry>
        <entry>附加信息</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>无</entry>
        <entry>clone new</entry>
        <entry><link linkend="language.oop5.cloning">clone</link> 和 <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>[</literal></entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>右</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">算术运算符</link></entry>
       </row>
       <row>
        <entry>右</entry>
        <entry>
         <literal>++</literal> 
         <literal>--</literal> 
         <literal>~</literal> 
         <literal>(int)</literal> 
         <literal>(float)</literal> 
         <literal>(string)</literal> 
         <literal>(array)</literal>
         <literal>(object)</literal> 
         <literal>(bool)</literal> 
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.types">类型</link>和<link linkend="language.operators.increment">递增／递减</link>
        </entry>
       </row>
       <row>
        <entry>无</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.types">类型</link>
        </entry>
       </row>
       <row>
        <entry>右</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">算术运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">算术运算符</link>和<link
         linkend="language.operators.string">字符串运算符</link></entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         <literal>&lt;&lt;</literal> 
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>
        </entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>
         <literal>&lt;</literal> 
         <literal>&lt;=</literal> 
         <literal>&gt;</literal> 
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">比较运算符</link>
        </entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal> 
         <literal>===</literal> 
         <literal>!==</literal> 
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">比较运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>和<link
         linkend="language.references">引用</link></entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">位运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.comparison">比较运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">ternary</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         <literal>=</literal> 
         <literal>+=</literal> 
         <literal>-=</literal> 
         <literal>*=</literal> 
         <literal>**=</literal> 
         <literal>/=</literal> 
         <literal>.=</literal> 
         <literal>%=</literal> 
         <literal>&amp;=</literal> 
         <literal>|=</literal> 
         <literal>^=</literal> 
         <literal>&lt;&lt;=</literal> 
         <literal>&gt;&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">赋值运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">逻辑运算符</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>结合方向</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// ternary operator associativity differs from C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Operator precedence and associativity only determine how expressions
    are grouped, they do not specify an order of evaluation. PHP does not
    (in the general case) specify in which order an expression is evaluated
    and code that assumes a specific order of evaluation should be avoided,
    because the behavior can change between versions of PHP or depending on
    the surrounding code.
    <example>
     <title>Undefined order of evaluation</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // may print either 2 or 3

$i = 1;
$array[$i] = $i++; // may set either index 1 or 2
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     尽管 <literal>=</literal> 比其它大多数的运算符的优先级低，PHP
     仍旧允许类似如下的表达式：<literal>if (!$a = foo())</literal>，在此例中
     <literal>foo()</literal> 的返回值被赋给了 <varname>$a</varname>。
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>算术运算符</title>
   <simpara>
    还记得学校里学到的基本数学知识吗？就和它们一样。
   </simpara>
   <table>
    <title>算术运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>取反</entry>
       <entry><varname>$a</varname> 的负值。</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>加法</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的和。</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>减法</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的差。</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乘法</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的积。</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>除法</entry>
       <entry><varname>$a</varname> 除以 <varname>$b</varname> 的商。</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>取模</entry>
       <entry><varname>$a</varname> 除以 <varname>$b</varname> 的余数。</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Exponentiation</entry>
       <entry>Result of raising <varname>$a</varname> to the <varname>$b</varname>'th power. Introduced in PHP 5.6.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    除法运算符总是返回浮点数。只有在下列情况例外：两个操作数都是整数（或字符串转换成的整数）并且正好能整除，这时它返回一个整数。
   </simpara>
   <simpara>
    取模运算符的操作数在运算之前都会转换成整数（除去小数部分）。
   </simpara>
   <para>
    取模运算符 <literal>%</literal> 的结果和被除数的符号（正负号）相同。即
    <literal>$a % $b</literal> 的结果和 <varname>$a</varname> 的符号相同。例如：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // prints 2
echo (5 % -3)."\n";          // prints 2
echo (-5 % 3)."\n";          // prints -2
echo (-5 % -3)."\n";         // prints -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    参见手册中的<link linkend="ref.math">数学函数</link>。
   </simpara>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>赋值运算符</title>
   <simpara>
    基本的赋值运算符是“=”。一开始可能会以为它是“等于”，其实不是的。它实际上意味着把右边表达式的值赋给左边的运算数。
   </simpara>
   <para>
    赋值运算表达式的值也就是所赋的值。也就是说，“<literal>$a = 3</literal>”的值是 3。这样就可以做一些小技巧：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a 现在成了 9，而 $b 成了 4。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   
   <para>
    在基本赋值运算符之外，还有适合于所有<link
    linkend="language.operators">二元算术</link>，数组集合和字符串运算符的“组合运算符”，这样可以在一个表达式中使用它的值并把表达式的结果赋给它，例如：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // sets $a to 8, as if we had said: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // sets $b to "Hello There!", just like $b = $b . "There!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    注意赋值运算将原变量的值拷贝到新变量中（传值赋值），所以改变其中一个并不影响另一个。这也适合于在密集循环中拷贝一些值例如大数组。
   </para>
   <para>
    在 PHP 中普通的传值赋值行为有个例外就是碰到对象 <type>object</type> 时，在
    PHP 5 中是以引用赋值的，除非明确使用了 <link
    linkend="language.oop5.cloning">clone</link> 关键字来拷贝。
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>引用赋值</title>
    <para>
     PHP 支持引用赋值，使用“<computeroutput>$var 
     = &amp;$othervar;</computeroutput>”语法。引用赋值意味着两个变量指向了同一个数据，没有拷贝任何东西。
    </para>
    <para>
     <example>
      <title>引用赋值</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b 是 $a 的引用

print "$a\n"; // 输出 3
print "$b\n"; // 输出 3

$a = 4; // 修改 $a

print "$a\n"; // 输出 4
print "$b\n"; // 也输出 4，因为 $b 是 $a 的引用，因此也被改变
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     自 PHP 5 起，<link linkend="language.oop5.basic.new">new</link>
     运算符自动返回一个引用，因此再对
     <link linkend="language.oop5.basic.new">new</link>
     的结果进行引用赋值在 PHP 5.3 以及以后版本中会发出一条
     <constant>E_DEPRECATED</constant> 错误信息，在之前版本会发出一条
     <constant>E_STRICT</constant> 错误信息。
    </para>
    <para>
     例如以下代码将产生警告：
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* The following line generates the following error message:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     有关引用更多信息参见本手册中<link
     linkend="language.references">引用的解释</link>一章。
    </para>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>位运算符</title>
   <simpara>
    位运算符允许对整型数中指定的位进行求值和操作。
   </simpara>

   <table>
    <title>位运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>And（按位与）</entry>
       <entry>将把 <varname>$a</varname> 和 <varname>$b</varname> 中都为 1 的位设为 1。</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Or（按位或）</entry>
       <entry>将把 <varname>$a</varname> 和 <varname>$b</varname> 中任何一个为 1 的位设为 1。</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Xor（按位异或）</entry>
       <entry>将把 <varname>$a</varname> 和 <varname>$b</varname> 中一个为 1 另一个为 0 的位设为 1。</entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Not（按位取反）</entry>
       <entry>将 <varname>$a</varname> 中为 0 的位设为 1，反之亦然。</entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Shift left（左移）</entry>
       <entry>将 <varname>$a</varname> 中的位向左移动 <varname>$b</varname> 次（每一次移动都表示“乘以 2”）。</entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Shift right（右移）</entry>
       <entry>将 <varname>$a</varname> 中的位向右移动 <varname>$b</varname> 次（每一次移动都表示“除以 2”）。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    位移在 PHP 中是数学运算。向任何方向移出去的位都被丢弃。左移时右侧以零填充，符号位被移走意味着正负号不被保留。右移时左侧以符号位填充，意味着正负号被保留。
   </para>
   <para>
    要用括号确保想要的<link linkend="language.operators.precedence">优先级</link>。例如
    <literal>$a &amp; $b == true</literal> 先进行比较再进行按位与；而
    <literal>($a &amp; $b) == true</literal> 则先进行按位与再进行比较。
   </para>
   <para>
    If both operands for the <literal>&amp;</literal>, <literal>|</literal> and
    <literal>^</literal> operators are strings, then the operation will be
    performed on the ASCII values of the characters that make up the strings and
    the result will be a string. In all other cases, both operands will be
    <link linkend="language.types.integer.casting">converted to integers</link>
    and the result will be an integer.
   </para>
   <para>
    If the operand for the <literal>~</literal> operator is a string, the
    operation will be performed on the ASCII values of the characters that make
    up the string and the result will be a string, otherwise the operand and the
    result will be treated as integers.
   </para>
   <para>
    Both operands and the result for the <literal>&lt;&lt;</literal> and
    <literal>&gt;&gt;</literal> operators are always treated as integers.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
PHP 的 ini 设定 error_reporting 使用了按位的值，
提供了关闭某个位的真实例子。要显示除了提示级别
之外的所有错误，php.ini 中是这样用的：
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
具体运作方式是先取得 E_ALL 的值：
<computeroutput>00000000000000000111011111111111</computeroutput>
再取得 E_NOTICE 的值：
<computeroutput>00000000000000000000000000001000</computeroutput>
然后通过 <literal>~</literal> 将其取反：
<computeroutput>11111111111111111111111111110111</computeroutput>
最后再用按位与 AND（&amp;）得到两个值中都设定了（为 1）的位：
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
另外一个方法是用按位异或 XOR（<literal>^</literal>）来取得只在
其中一个值中设定了的位：
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting 也可用来演示怎样置位。只显示错误和可恢复
错误的方法是：
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
也就是将 E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
和 E_RECOVERABLE_ERROR
<computeroutput>00000000000000000001000000000000</computeroutput>
用按位或 OR（<literal>|</literal>）运算符来取得在任何一个值中被置位的结果：
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>整数的 AND，OR 和 XOR 位运算符</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignore the top section,
 * it is just formatting to make output clearer.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * Here are the examples.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>字符串的 XOR 运算符</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Outputs '5'

echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Outputs 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Outputs 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>整数的位移</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Here are the examples.
 */

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'sign bits get shifted out');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side');


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


/*
 * Ignore this bottom section,
 * it is just formatting to make output clearer.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binary:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTE: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Shifting integers by values greater than or equal to the system long
     integer width results in undefined behavior. In other words, don't shift
     more than 31 bits on a 32-bit system, and don't shift more than 63 bits on
     a 64-bit system.
</para>
    <para>
     使用 <link linkend="book.gmp">gmp</link> 扩展对超出 <literal>PHP_INT_MAX</literal> 的数值来进行位操作。
    </para>
   </warning>
   <para>
    参见
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>比较运算符</title>
   <simpara>
    比较运算符，如同它们名称所暗示的，允许对两个值进行比较。还可以参考
    <link linkend="types.comparisons">PHP 类型比较表</link>看不同类型相互比较的例子。
   </simpara>
   <table>
    <title>比较运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等于</entry>
       <entry>&true;，如果类型转换后 <varname>$a</varname> 等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>全等</entry>
       <entry>&true;，如果 <varname>$a</varname> 等于 <varname>$b</varname>，并且它们的类型也相同。</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>不等</entry>
       <entry>&true;，如果类型转换后 <varname>$a</varname> 不等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>不等</entry>
       <entry>&true;，如果类型转换后 <varname>$a</varname> 不等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>不全等</entry>
       <entry>&true;，如果 <varname>$a</varname> 不等于 <varname>$b</varname>，或者它们的类型不同。</entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>小与</entry>
       <entry>&true;，如果 <varname>$a</varname> 严格小于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>大于</entry>
       <entry>&true;，如果 <varname>$a</varname> 严格大于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>小于等于</entry>
       <entry>&true;，如果 <varname>$a</varname> 小于或者等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>大于等于</entry>
       <entry>&true;，如果 <varname>$a</varname> 大于或者等于 <varname>$b</varname>。</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>结合比较运算符</entry>
       <entry>
        当<varname>$a</varname>小于、等于、大于than <varname>$b</varname>时
        分别返回一个小于、等于、大于0的<type>integer</type> 值。
        PHP7开始提供.
       </entry>
      </row>
      <row>
       <entry>$a ?? $b ?? $c</entry>
       <entry>NULL 合并操作符</entry>
       <entry>
        从左往右第一个存在且不为 &null; 的操作数。如果都没有定义且不为 &null;，则返回 &null;。PHP7开始提供。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被<link
    linkend="language.types.string.conversion">转换为数值</link>并且比较按照数值来进行。此规则也适用于
    <link linkend="control-structures.switch">switch</link> 语句。当用 === 或 !==
    进行比较时则不进行类型转换，因为此时类型和数值都要比对。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // never reached because "a" is already matched with 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
     <programlisting role="php">
<![CDATA[
<?php  
// Integers
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Floats
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Strings
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Arrays
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Objects
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// only values are compared
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>
]]>
      
     </programlisting>
    </informalexample>
   </para>

   <para>
    对于多种类型，比较运算符根据下表比较（按顺序）。
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>比较多种类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>运算数 1 类型</entry>
       <entry>运算数 2 类型</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> 或 <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>将 &null; 转换为 ""，进行数字或词汇比较</entry>
      </row>
      <row>
       <entry><type>bool</type> 或 <type>null</type></entry>
       <entry>任何其它类型</entry>
       <entry>转换为 <type>bool</type>，&false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>
        内置类可以定义自己的比较，不同类不能比较，相同类和数组同样方式比较属性（PHP
        4 中），PHP 5 有其自己的<link
        linkend="language.oop5.object-comparison">说明</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>，<type>resource</type> 或 <type>number</type></entry>
       <entry><type>string</type>，<type>resource</type> 或 <type>number</type></entry>
       <entry>将字符串和资源转换成数字，按普通数学比较</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>
        具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数
        2 中则数组无法比较，否则挨个值比较（见下例）
       </entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>任何其它类型</entry>
       <entry><type>object</type> 总是更大</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>任何其它类型</entry>
       <entry><type>array</type> 总是更大</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>标准数组比较代码</title>
     <programlisting role="php">
<![CDATA[
<?php
// 数组是用标准比较运算符这样比较的
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>


   <para>
    <example>
     <title>Transcription of standard array comparison</title>
     <programlisting role="php">
<![CDATA[
<?php
// Arrays are compared like this with standard comparison operators
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    参见 <function>strcasecmp</function>，<function>strcmp</function>，<link
    linkend="language.operators.array">数组运算符</link>和<link linkend="language.types">类型</link>章节。
   </para>

   <warning>
    <title>比较浮点数</title>

    <para>
     由于浮点数 <type>float</type> 的内部表达方式，不应比较两个浮点数<type>float</type>是否相等。
    </para>

    <para>
     更多信息参见 <type>float</type>。
    </para>
   </warning>

  <sect2 xml:id="language.operators.comparison.ternary">
    <title>三元运算符</title>
    <para>
     另一个条件运算符是“?:”（或三元）运算符 。
     <example>
      <title>赋默认值</title>
      <programlisting role="php">
<![CDATA[
<?php
// Example usage for: Ternary Operator
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// The above is identical to this if/else statement
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     表达式 <literal>(expr1) ? (expr2) : (expr3)</literal> 在
     <replaceable>expr1</replaceable> 求值为 &true;
     时的值为 <replaceable>expr2</replaceable>，在
     <replaceable>expr1</replaceable> 求值为 &false; 时的值为
     <replaceable>expr3</replaceable>。
    </para>
    <para>
     自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式
     <literal>expr1 ?: expr3</literal> 在
     <replaceable>expr1</replaceable> 求值为 &true; 时返回
     <replaceable>expr1</replaceable>，否则返回
     <replaceable>expr3</replaceable>。
    </para>
    <note>
     <simpara>
      注意三元运算符是个语句，因此其求值不是变量，而是语句的结果。如果想通过引用返回一个变量这点就很重要。在一个通过引用返回的函数中语句
      <literal>return $var == 42 ? $a : $b;</literal> 将不起作用，以后的 PHP
      版本会为此发出一条警告。
     </simpara>
    </note>
    <note>
     <para>
      建议避免将三元运算符堆积在一起使用。当在一条语句中使用多个三元运算符时会造成
      PHP 运算结果不清晰：
      <example>
       <title>不清晰的三元运算符行为</title>
       <programlisting role="php">
<![CDATA[
<?php
// 乍看起来下面的输出是 'true'
echo (true?'true':false?'t':'f');

// 然而，上面语句的实际输出是't'，因为三元运算符是从左往右计算的

// 下面是与上面等价的语句，但更清晰
echo ((true ? 'true' : 'false') ? 't' : 'f');

// here, you can see that the first expression is evaluated to 'true', which
// in turn evaluates to (bool)true, thus returning the true branch of the
// second ternary expression.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>错误控制运算符</title>
   <simpara>
    PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP
    表达式之前，该表达式可能产生的任何错误信息都被忽略掉。
   </simpara>
   <simpara>
    如果用 <function>set_error_handler</function>
    设定了自定义的错误处理函数，仍然会被调用，但是此错误处理函数可以（并且也应该）调用
    <function>error_reporting</function>，而该函数在出错语句前有 @ 时将返回 0。
   </simpara>
   <simpara>
    如果激活了 <link linkend="ini.track-errors"><option>track_errors</option></link>
    特性，表达式所产生的任何错误信息都被存放在变量
    <varname>$php_errormsg</varname>
    中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Intentional file error */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// this works for any expression, not just functions:
$value = @$cache[$key];
// will not issue a notice if the index $key doesn't exist.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @ 运算符只对<link linkend="language.expressions">表达式</link>有效。对新手来说一个简单的规则就是：如果能从某处得到值，就能在它前面加上
     @ 运算符。例如，可以把它放在变量，函数和 <function>include</function>
     调用，常量，等等之前。不能把它放在函数或类的定义之前，也不能用于条件结构例如
     <literal>if</literal> 和 &foreach; 等。
    </simpara>
   </note>
   <simpara>
    参见 <function>error_reporting</function>
    及手册中<link linkend="ref.errorfunc">错误处理及日志函数</link>的有关章节。
   </simpara>
   <warning>
    <para>
     目前的“@”错误控制运算符前缀甚至使导致脚本终止的严重错误的错误报告也失效。这意味着如果在某个不存在或者敲错了字母的函数调用前用了“@”来抑制错误信息，那脚本会没有任何迹象显示原因而死在那里。
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>执行运算符</title>
   <para>
    PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP
    将尝试将反引号中的内容作为外壳命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数
    <function>shell_exec</function> 相同。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     反引号运算符在激活了&safemode;或者关闭了 <function>shell_exec</function> 时是无效的。
    </para>
   </note>
   <note>
    <para>
     与其它某些语言不同，反引号不能在双引号字符串中使用。
    </para>
   </note>
   <para>
    参见手册中<link linkend="ref.exec">程序执行函数</link>，<function>popen</function>，<function>proc_open</function>
    以及 <link linkend="features.commandline">PHP 的命令行模式</link>。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>递增／递减运算符</title>
   <para>
    PHP 支持 C 风格的前／后递增与递减运算符。
   </para>
   <note>
    <simpara>
     递增／递减运算符不影响布尔值。递减
     &null; 值也没有效果，但是递增 &null; 的结果是 <literal>1</literal>。
    </simpara>
   </note>
   <table>
    <title>递增／递减运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>效果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前加</entry>
       <entry><varname>$a</varname> 的值加一，然后返回 <varname>$a</varname>。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>后加</entry>
       <entry>返回 <varname>$a</varname>，然后将 <varname>$a</varname> 的值加一。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前减</entry>
       <entry><varname>$a</varname> 的值减一， 然后返回 <varname>$a</varname>。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>后减</entry>
       <entry>返回 <varname>$a</varname>，然后将 <varname>$a</varname> 的值减一。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    一个简单的示例脚本：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Postdecrement</h3>";
$a = 5;
echo "Should be 5: " . $a-- . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";

echo "<h3>Predecrement</h3>";
$a = 5;
echo "Should be 4: " . --$a . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在
    Perl 中 <literal>$a = 'Z'; $a++;</literal> 将把 <literal>$a</literal>
    变成<literal>'AA'</literal>，而在 C 中，<literal>a = 'Z'; a++;</literal> 将把
    <literal>a</literal> 变成 <literal>'['</literal>（<literal>'Z'</literal>
    的 ASCII 值是 90，<literal>'['</literal> 的 ASCII 值是
    91）。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和
    A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。
    <example>
     <title>涉及字符变量的算数运算</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Alphabets ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// Digit characters behave differently
echo '== Digits ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Characters ==
X
Y
Z
AA
AB
AC
== Digits ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    递增或递减布尔值没有效果。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>逻辑运算符</title>

   <table>
    <title>逻辑运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And（逻辑与）</entry>
       <entry>&true;，如果 <varname>$a</varname> 和 <varname>$b</varname> 都为 &true;。</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or（逻辑或）</entry>
       <entry>&true;，如果 <varname>$a</varname> 或 <varname>$b</varname> 任一为 &true;。</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor（逻辑异或）</entry>
       <entry>&true;，如果 <varname>$a</varname> 或 <varname>$b</varname> 任一为 &true;，但不同时是。</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not（逻辑非）</entry>
       <entry>&true;，如果 <varname>$a</varname> 不为 &true;。</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And（逻辑与）</entry>
       <entry>&true;，如果 <varname>$a</varname> 和 <varname>$b</varname> 都为 &true;。</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or（逻辑或）</entry>
       <entry>&true;，如果 <varname>$a</varname> 或 <varname>$b</varname> 任一为 &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    “与”和“或”有两种不同形式运算符的原因是它们运算的优先级不同（见<link linkend="language.operators.precedence">运算符优先级</link>）。
   </simpara>
   <example>
    <title>逻辑运算符示例</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() 根本没机会被调用，被运算符“短路”了

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" 比 "or" 的优先级高

// 表达式 (false || true) 的结果被赋给 $e
// 等同于：($e = (false || true))
$e = false || true;

// 常量 false 被赋给 $f，true 被忽略
// 等同于：(($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" 比 "and" 的优先级高

// 表达式 (true && false) 的结果被赋给 $g
// 等同于：($g = (true && false))
$g = true && false;

// 常量 true 被赋给 $h，false 被忽略
// 等同于：(($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>字符串运算符</title>
   <simpara>
    有两个字符串（<type>string</type>）运算符。第一个是连接运算符（“.”），它返回其左右参数连接后的字符串。第二个是连接赋值运算符（“.=”），它将右边参数附加到左边的参数之后。更多信息见<link
    linkend="language.operators.assignment">赋值运算符</link>。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // now $b contains "Hello World!"

$a = "Hello ";
$a .= "World!";     // now $a contains "Hello World!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    参见<link linkend="language.types.string">字符串类型</link>和<link linkend="ref.strings">字符串函数</link>章节。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>数组运算符</title>
   <table>
    <title>数组运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>联合</entry>
       <entry><varname>$a</varname> 和 <varname>$b</varname> 的联合。</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>相等</entry>
       <entry>如果 <varname>$a</varname> 和 <varname>$b</varname> 具有相同的键／值对则为 &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>全等</entry>
       <entry>如果 <varname>$a</varname> 和 <varname>$b</varname> 具有相同的键／值对并且顺序和类型都相同则为 &true;。</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>不等</entry>
       <entry>如果 <varname>$a</varname> 不等于 <varname>$b</varname> 则为 &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>不等</entry>
       <entry>如果 <varname>$a</varname> 不等于 <varname>$b</varname> 则为 &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>不全等</entry>
       <entry>如果 <varname>$a</varname> 不全等于 <varname>$b</varname> 则为 &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <literal>+</literal> 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Union of $b and $a
echo "Union of \$b and \$a: \n";
var_dump($c);

$a += $b; // Union of $a += $b is $a and $b
echo "Union of \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    执行后，此脚本会显示：
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
Union of $a += $b:
array(3) {
  'a' =>
  string(5) "apple"
  'b' =>
  string(6) "banana"
  'c' =>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    数组中的单元如果具有相同的键名和值则比较时相等。
   </para>
   <para>
    <example>
     <title>比较数组</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    参见<link linkend="language.types.array">数组类型</link>和<link
    linkend="ref.array">数组函数</link>章节。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>类型运算符</title>
   <para>
    <literal>instanceof</literal> 用于确定一个 PHP 变量是否属于某一类 
    <link linkend="language.oop5.basic.class">class</link> 的实例：
    <example>
     <title>对类使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal>　也可用来确定一个变量是不是继承自某一父类的子类的实例：
    <example>
     <title>对继承类使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    检查一个对象是否<emphasis>不是</emphasis>某个类的实例，可以使用<link 
    linkend="language.operators.logical">逻辑运算符 <literal>not</literal></link>。
    <example>
     <title>使用 <literal>instanceof</literal> 检查对象<emphasis>不是</emphasis>某个类的实例</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    最后，<literal>instanceof</literal>也可用于确定一个变量是不是实现了某个<link 
    linkend="language.oop5.interfaces">接口</link>的对象的实例:
    <example>
     <title>对接口使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    虽然 <literal>instanceof</literal> 通常直接与类名一起使用，但也可以使用对象或字符串变量：
    <example>
     <title>对其它变量使用 <literal>instanceof</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b is an object of class MyClass
var_dump($a instanceof $c); // $c is a string 'MyClass'
var_dump($a instanceof $d); // $d is a string 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回
    &false;。不允许用来检测常量。
    <example>
     <title>用 <literal>instanceof</literal> 检测其它变量</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a is an integer
var_dump($b instanceof stdClass); // $b is NULL
var_dump($c instanceof stdClass); // $c is a resource
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    然而 instanceof 的使用还有一些陷阱必须了解。在
    PHP 5.1.0 之前，如果要检查的类名称不存在，<literal>instanceof</literal> 会调用
    <function>__autoload</function>。另外，如果该类没有被装载则会产生一个致命错误。可以通过使用动态类引用或用一个包含类名的字符串变量来避开这种问题：
    <example>
     <title>避免 PHP 5.0 中 instanceof 引起的类名查找和致命错误问题</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // no fatal error here
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    <literal>instanceof</literal> 运算符是 PHP 5 引进的。在此之前用
    <function>is_a</function>，但是后来
    <function>is_a</function> 被废弃而用 <literal>instanceof</literal>
    替代了。注意自 PHP 5.3.0 起，又恢复使用 <function>is_a</function> 了。
   </simpara>
   <para>
    参见 <function>get_class</function> 和
    <function>is_a</function>。
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
