<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
 <chapter id="functions">
  <title>函数</title>

  <sect1 id="functions.user-defined">
   <title>用户自定义函数</title>
 
   <para>
    一个函数可由以下的语法来定义：
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   
   <!--
    
    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)
    
    -->
     
   <simpara>
    任何有效的 PHP 代码都可能出现在函数内部，甚至其他函数和
    <link linkend="keyword.class">class</link> 定义。
   </simpara>
   <simpara>
    在 PHP 3 中，函数函数必须在它们被调用之前定义。PHP 4 中不在有这样的
    条件。
   </simpara>
   <simpara>
    PHP 不支持函数重载，可能也不支持取消定义或者重定义已声明的函数。
   </simpara>
   <simpara>
    PHP 3 does not support variable numbers of arguments to functions,
    PHP 3 虽然支持默认参数（更多的信息请参照
    <link linkend="functions.arguments.default">默认参数的值</link>）
    ，但是却不支持可变的参数个数。
    PHP 4 支持: 见 <link
    linkend="functions.variable-arg-list">Variable-length argument
    lists</link> and the function references for
    <function>func_num_args</function>,
    <function>func_get_arg</function>, and
    <function>func_get_args</function> for more information.
   </simpara>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>函数的参数</title>
 
   <simpara>
    Information may be passed to functions via the argument list,
    which is a comma-delimited list of variables and/or constants.
   </simpara> 
   <para>
     PHP supports passing arguments by value (the default), <link
     linkend="functions.arguments.by-reference">passing by
     reference</link>, and <link
     linkend="functions.arguments.default">default argument
     values</link>. Variable-length argument lists are supported only
     in PHP 4 and later; see <link
     linkend="functions.variable-arg-list">Variable-length argument
     lists</link> and the function references for
     <function>func_num_args</function>,
     <function>func_get_arg</function>, and
     <function>func_get_args</function> for more information. A
     similar effect can be achieved in PHP 3 by passing an array of
     arguments to a function:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>通过引用传递参数</title>
 
    <simpara>
     缺省情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它
     并不会改变函数外部的值）。如果你希望允许函数修改它的参数值，你必须
     通过引用传递参数。
    </simpara>
    <para>
     如果想要函数的一个参数总是通过引用传递，你可以在函数定义中该参数的
     前面预先加上符号（&）：
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
]]>
      </programlisting>
     </informalexample>
    </para>
 
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>默认参数的值</title>
 
    <para>
     函数可以定义 C++ 风格的标量参数默认值，如下：
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function makecoffee ($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee ();
echo makecoffee ("espresso");
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     上述片断的输出是：
     <screen>
Making a cup of cappuccino.
Making a cup of espresso.
     </screen>
    </para>
 
    <simpara>
     默认值必须是标量，不是（比如）变量或者类成员。
    </simpara>
    <para>
     请注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，
     可能函数将不会按照预期的情况工作。考虑下面的代码片断：

     <informalexample>
      <programlisting role="php">
<![CDATA[
function makeyogurt ($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // won't work as expected
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     上述例子的输出时：
 
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
 
    <para>
     现在，比较上面的例子和这个例子：
     <informalexample>
      <programlisting role="php">
<![CDATA[
function makeyogurt ($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // works as expected
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     这个例子的输出是：
 
     <screen>
Making a bowl of acidophilus raspberry.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Variable-length argument lists</title>
	
    <simpara>
     PHP 4 has support for variable-length argument lists in
     user-defined functions. This is really quite easy, using the
     <function>func_num_args</function>,
     <function>func_get_arg</function>, and
     <function>func_get_args</function> functions.
    </simpara>

    <simpara>
     No special syntax is required, and argument lists may still be
     explicitly provided with function definitions and will behave as
     normal.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>返回值</title>
 
   <para>
    Values are returned by using the optional return statement. Any
    type may be returned, including lists and objects. This causes the
    function to end its execution immediately and pass control back to
    the line from which it was called. See <function>return</function>
    for more information.
    <informalexample>
     <programlisting role="php">
<![CDATA[
function square ($num)
{
    return $num * $num;
}
echo square (4);   // outputs '16'.
]]>
     </programlisting>
    </informalexample>
   </para>
      
   <para>
    你不能从函数返回多个值，但返回一个列表可以获得简单的结果。
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    从函数返回一个引用，你必须在函数申明和支派返回值给一个变量时都使用引用操作符 &amp; ：
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    有关引用的更多信息, 请查看 <link
    linkend="language.references">引用的解释</link>.
   </simpara>
  </sect1>
 
  <sect1 id="functions.old-syntax">
   <title><literal>旧的函数</literal></title>
 
   <simpara>
    <literal>old_function</literal> 语句允许你使用 PHP/FI2 的语法声明函数，
    （你必须把‘function’替换为‘old_function’）

    <literal>旧的函数</literal> 
   </simpara>
   <simpara>
    这是一个不被赞成的特性，应该只用在 PHP/FI2->PHP 3 转换器中。
   </simpara>
   <warning>
    <para>
     Functions declared as <literal>old_function</literal> cannot be
     called from PHP's internal code. Among other things, this means
     you can't use them in functions such as
     <function>usort</function>, <function>array_walk</function>, and
     <function>register_shutdown_function</function>. You can get
     around this limitation by writing a wrapper function (in normal
     PHP 3 form) to call the <literal>old_function</literal>.


    </para>
   </warning>

  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Variable functions</title>

   <para>
    PHP supports the concept of variable functions. This means that if
    a variable name has parentheses appended to it, PHP will look for
    a function with the same name as whatever the variable evaluates
    to, and will attempt to execute it. Among other things, this can
    be used to implement callbacks, function tables, and so forth.
   </para>
   <para>
    Variable functions won't work with language constructs such 
    as <function>echo</function>, <function>unset</function>,
    <function>isset</function>, <function>empty</function> and 
    <function>include</function>.  Although, the construct 
    <function>print</function> is an exception and will work.  
    This is one of the major differences between PHP functions and 
    language constructs. 
   </para>
   <para>
    <example>
     <title>Variable function example</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br>\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br>\n";
}

$func = 'foo';
$func();
$func = 'bar';
$func('test');
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    See also <link linkend="language.variables.variable">
    variable variables</link> and <function>function_exists</function>.
   </para>

  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
