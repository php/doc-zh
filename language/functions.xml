<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- $Author$ -->
<!-- EN-Revision: 4f04bd50ed71039b89e2b9a5aba7e53e74cac4c6 Maintainer: avenger Status: ready -->
<!-- CREDITS: Gregory, dallas -->
<chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>函数</title>

  <sect1 xml:id="functions.user-defined">
   <title>用户自定义函数</title>

   <para>
    一个函数可由以下的语法来定义：
   </para>
   <para>
    <example>
     <title>展示函数用途的伪代码</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和
    <link linkend="language.oop5.basic.class">类</link> 定义。
   </simpara>
   <para>
    函数名和 PHP 中的其它标识符命名规则相同。有效的函数名以字母或下划线打头，后面跟字母，数字或下划线。可以用正则表达式表示为:
    <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>。
   </para>
   &tip.userlandnaming;
   <simpara>
    函数无需在调用之前被定义，<emphasis>除非</emphasis> 是下面两个例子中函数是有条件被定义时。
   </simpara>
   <para>
    当一个函数是有条件被定义时，必须在调用函数 <emphasis>之前</emphasis> 定义。
   </para>
   <para>
    <example>
     <title>有条件的函数</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* 不能在此处调用foo()函数，
   因为它还不存在，但可以调用bar()函数。*/

bar();

if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* 现在可以安全调用函数 foo()
   因为 $makefoo 值为真 */

if ($makefoo) foo();

function bar()
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>函数中的函数</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* 现在还不能调用 bar() 函数，因为它还不存在 */

foo();

/* 现在可以调用 bar() 函数了，因为 foo() 函数
   的执行使得 bar() 函数变为已定义的函数 */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP 中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用，反之亦然。
   </para>
   <simpara>
    PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。
   </simpara>
   <note>
    <simpara>
     从 <literal>A</literal> 到 <literal>Z</literal>
     的 ASCII 函数名是大小写无关的，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。
    </simpara>
   </note>
   <simpara>
    PHP 的函数支持 <link linkend="functions.variable-arg-list">可变数量的参数</link> 和
    <link linkend="functions.arguments.default">默认参数</link>。参见
    <function>func_num_args</function>，<function>func_get_arg</function> 和 <function>func_get_args</function>。
   </simpara>

   <para>
    在 PHP 中可以调用递归函数。
    <example>
     <title>递归函数</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
    但是要避免递归函数／方法调用超过 100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止。
    无限递归可视为编程错误。
    </simpara>
   </note>
   </para>

  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>函数的参数</title>

   <simpara>
    通过参数列表可以传递信息到函数，即以逗号作为分隔符的表达式列表。参数是从左向右求值的。
   </simpara>

   <para>
    PHP 支持按值传递参数（默认），<link
    linkend="functions.arguments.by-reference">通过引用传递参数</link> 以及 <link
    linkend="functions.arguments.default">默认参数</link>。也支持 <link
    linkend="functions.variable-arg-list">可变长度参数列表</link>。
   </para>
   <para>
    <example>
     <title>向函数传递数组</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    从 PHP 8.0.0 开始，函数参数列表可以包含一个尾部的逗号，这个逗号将被忽略。这在参数列表较长或包含较长的变量名的情况下特别有用，这样可以方便地垂直列出参数。
   </para>
   <example>
    <title>函数参数使用尾部逗号</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // 在 8.0.0 之前，这个尾部的逗号是不允许的。
)
{
    // ...
}
?>
]]>
    </programlisting>
   </example>
   <para>
    As of PHP 8.0.0, passing mandatory arguments after optional arguments
    is deprecated. This can generally be resolved by dropping the default value.
    One exception to this rule are arguments of the form
    <code>Type $param = null</code>, where the &null; default makes the type implicitly
    nullable. This usage remains allowed, though it is recommended to use an
    explicit nullable type instead.
   </para>
   <example>
    <title>Passing optional arguments after mandatory arguments</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($a = [], $b) {} // 之前
function foo($a, $b) {}      // 之后

function bar(A $a = null, $b) {} // 同时可用
function bar(?A $a, $b) {}       // 官方推荐的写法
?>
]]>
    </programlisting>
   </example>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>通过引用传递参数</title>

    <simpara>
     默认情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它并不会改变函数外部的值）。如果希望允许函数修改它的参数值，必须通过引用传递参数。
    </simpara>
    <para>
     如果想要函数的一个参数总是通过引用传递，可以在函数定义中该参数的前面加上符号 &amp;：
    </para>
    <para>
     <example>
      <title>用引用传递函数参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="functions.arguments.default">
    <title>默认参数的值</title>

    <para>
     函数可以定义 C++ 风格的标量参数默认值，如下所示：
    </para>
    <para>
     <example>
      <title>在函数中使用默认参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Making a cup of cappuccino.
Making a cup of .
Making a cup of espresso.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP 还允许使用数组 <type>array</type> 和特殊类型 &null; 作为默认参数，例如：
    </para>
    <para>
     <example>
      <title>使用非标量类型作为默认参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Making a cup of ".join(", ", $types)." with $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     默认值必须是常量表达式，不能是诸如变量，类成员，或者函数调用等。
    </simpara>
    <para>
     注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，函数将不会按照预期的情况工作。考虑下面的代码片断：
    </para>
    <para>
     <example>
      <title>函数默认参数的不正确用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}

echo makeyogurt("raspberry");   // won't work as expected
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to makeyogurt() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Making a bowl of raspberry .
]]>
      </screen>
     </example>
    </para>
    <para>
     现在，比较上面的例子和这个例子：
    </para>
    <para>
     <example>
      <title>函数默认参数正确的用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}

echo makeyogurt("raspberry");   // works as expected
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Making a bowl of acidophilus raspberry.
]]>
      </screen>
     </example>
    </para>
    <note>
     <simpara>
      传引用的参数也可以有默认值。
     </simpara>
    </note>
   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>可变数量的参数列表</title>

    <simpara>
     PHP 在用户自定义函数中支持可变数量的参数列表。由
     <literal>...</literal> 语法实现。
    </simpara>

    <note>
     <simpara>
      还可以使用以下函数来获取可变参数
      <function>func_num_args</function>、
      <function>func_get_arg</function> 和
      <function>func_get_args</function>，不建议使用此方式，请使用
      <literal>...</literal> 来替代。
     </simpara>
    </note>

    <para>
     包含 <literal>...</literal>
     的参数，会转换为指定参数变量的一个数组，见以下示例：

     <example>
      <title>使用 <literal>...</literal> 来访问变量参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>

    <para>
    也可以使用 <literal>...</literal> 语法来传递 <type>array</type> 或
     <classname>Traversable</classname> 做为参数到函数中：


     <example>
      <title>使用 <literal>...</literal> 来传递参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3
3
]]>
      </screen>
     </example>
    </para>

    <para>
     你可以在
     <literal>...</literal> 前指定正常的位置参数。在这种情况下，只有不符合位置参数的尾部参数才会被添加到
     <literal>...</literal> 生成的数组中。
    </para>

    <para>
     你也可以在
     <literal>...</literal> 标记前添加一个
     <link linkend="language.types.declarations">类型声明</link>。如果存在这种情况，那么
     <literal>...</literal> 捕获的所有参数必须是提示类的对象。


     <example>
      <title>输入提示的变量参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// This will fail, since null isn't a DateInterval object.
echo total_intervals('d', null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
      </screen>
     </example>
    </para>

    <para>
      最后，你还可以给参数传递
     <link linkend="functions.arguments.by-reference">引用变量</link>，通过在
      <literal>...</literal> 前加上一个 (<literal>&amp;</literal>) 符号来实现。
    </para>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>旧版本的 PHP</title>

     <para>
      不需要特殊的语法来声明一个函数是可变的；但是访问函数的参数必须使用
      <function>func_num_args</function>, <function>func_get_arg</function>
      和 <function>func_get_args</function> 函数。
     </para>

     <para>
      上面的第一个例子在早期 PHP 版本中的实现如下：

      <example>
       <title>在 PHP 早期版本中访问可变参数</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

   <sect2 xml:id="functions.named-arguments">
    <title>Named Arguments</title>

    <para>
     PHP 8.0.0 introduced named arguments as an extension of the existing
     positional parameters. Named arguments allow passing arguments to a
     function based on the parameter name, rather than the parameter position.
     This makes the meaning of the argument self-documenting, makes the
     arguments order-independent and allows skipping default values arbitrarily.
    </para>

    <para>
     Named arguments are passed by prefixing the value with the parameter name
     followed by a colon. Using reserved keywords as parameter names is allowed.
     The parameter name must be an identifier, specifying dynamically
     is not allowed.
    </para>

    <example>
     <title>Named argument syntax</title>
     <programlisting role="php">
      <![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// NOT supported.
function_name($variableStoringParamName: $value);
?>
]]>
     </programlisting>
    </example>

    <example>
     <title>Positional arguments versus named arguments</title>
     <programlisting role="php">
      <![CDATA[
<?php
// Using positional arguments:
array_fill(0, 100, 50);

// Using named arguments:
array_fill(start_index: 0, count: 100, value: 50);
?>
]]>
     </programlisting>
    </example>

    <para>
     The order in which the named arguments are passed does not matter.
    </para>

    <example>
     <title>Same example as above with a different order of parameters</title>
     <programlisting role="php">
      <![CDATA[
<?php
array_fill(value: 50, num: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>

    <para>
     Named arguments can be combined with positional arguments. In this case,
     the named arguments must come after the positional arguments.
     It is also possible to specify only some of the optional arguments of a
     function, regardless of their order.
    </para>

    <example>
     <title>Combining named arguments with positional arguments</title>
     <programlisting role="php">
      <![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// Same as
htmlspecialchars($string, ENT_COMPAT | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>

    <para>
     Passing the same parameter multiple times results in an Error exception.
    </para>

    <example>
     <title>Error exception when passing the same parameter multiple times</title>
     <programlisting role="php">
      <![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
]]>
     </programlisting>
    </example>

   </sect2>
  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>返回值</title>

   <para>
    值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。更多信息见
    <function>return</function>。
   </para>
   <note>
    <para>
     如果省略了
     <function>return</function>，则返回值为 &null;。
    </para>
   </note>

   <sect2>
    <title>return 的使用</title>
    <para>
     <example>
     <title><function>return</function> 的使用</title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // outputs '16'.
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     函数不能返回多个值，但可以通过返回一个数组来得到类似的效果。
    </para>
    <para>
     <example>
      <title>返回一个数组以得到多个返回值</title>
      <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &amp;：
    </para>
    <para>
     <example>
      <title>从函数返回一个引用</title>
      <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
    有关引用的更多信息, 请查看 <link linkend="language.references">引用的解释</link>。
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>可变函数</title>

   <para>
    PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP
    将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。
   </para>
   <para>
    可变函数不能用于例如
    <function>echo</function>，<function>print</function>，<function>unset</function>，<function>isset</function>，<function>empty</function>，<function>include</function>，<function>require</function>
    以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。
   </para>
   <para>
    <example>
     <title>可变函数示例</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// 使用 echo 的包装函数
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    也可以用可变函数的语法来调用一个对象的方法。
    <example>
     <title>可变方法范例</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // This calls the Bar() method
    }

    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // This calls $foo->Variable()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    当调用静态方法时，函数调用要比静态属性优先：
    <example>
     <title>Variable 方法和静态属性示例</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.
$variable = "Variable";
Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Complex callables</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$func = array(new Foo, "baz");
$func(); // prints "baz"
$func = "Foo::bar";
$func(); // prints "bar"
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>is_callable</function></member>
      <member><function>call_user_func</function></member>
      <member><function>function_exists</function></member>
      <member><link linkend="language.variables.variable">variable variables</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
  <title>内部（内置）函数</title>

  <para>
   PHP 有很多标准的函数和结构。还有一些函数需要和特定地 PHP
   扩展模块一起编译，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。例如，要使用
   <link linkend="ref.image">image</link> 函数中的
   <function>imagecreatetruecolor</function>，需要在编译 PHP 的时候加上
   <productname>GD</productname> 的支持。或者，要使用
   <function>mysqli_connect</function> 函数，就需要在编译 PHP 的时候加上
   <link linkend="book.mysqli">MySQLi</link> 支持。有很多核心函数已包含在每个版本的
   PHP 中如<link linkend="ref.strings">字符串</link>和<link
   linkend="ref.var">变量</link>函数。调用
   <function>phpinfo</function> 或者 <function>get_loaded_extensions</function>
   可以得知 PHP 加载了那些扩展库。同时还应该注意，很多扩展库默认就是有效的。PHP
   手册按照不同的扩展库组织了它们的文档。请参阅<link linkend="configuration">配置</link>，<link
   linkend="install">安装</link>以及各自的扩展库章节以获取有关如何设置 PHP 的信息。
  </para>
  <para>
   手册中<link
   linkend="about.prototypes">如何阅读函数原型</link>讲解了如何阅读和理解一个函数的原型。确认一个函数将返回什么，或者函数是否直接作用于传递的参数是很重要的。例如，<function>str_replace</function>
   函数将返回修改过的字符串，而 <function>usort</function>
   却直接作用于传递的参数变量本身。手册中，每一个函数的页面中都有关于函数参数、行为改变、成功与否的返回值以及使用条件等信息。了解这些重要的（常常是细微的）差别是编写正确的
   PHP 代码的关键。
   </para>
   <note>
    <simpara>
     如果传递给函数的参数类型与实际的类型不一致，例如将一个 <type>array</type>
     传递给一个 <type>string</type> 类型的变量，那么函数的返回值是不确定的。在这种情况下，通常函数会返回
     &null;。但这仅仅是一个惯例，并不一定如此。
    </simpara>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>function_exists</function></member>
      <member><link linkend="funcref">the function reference</link></member>
      <member><function>get_extension_funcs</function></member>
      <member><function>dl</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>匿名函数</title>

   <simpara>
    匿名函数（Anonymous functions），也叫闭包函数（<literal>closures</literal>），允许
    临时创建一个没有指定名称的函数。最经常用作回调函数 <type>callable</type>参数的值。当然，也有其它应用的情况。
   </simpara>
   <simpara>
    匿名函数目前是通过 <link linkend="class.closure">
    <classname>Closure</classname></link> 类来实现的。
   </simpara>

   <example>
    <title>匿名函数示例</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// 输出 helloWorld
?>
]]>
    </programlisting>
   </example>

   <simpara>
    闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类
    <classname>Closure</classname> 的对象实例。把一个 closure
    对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号：
   </simpara>

   <example>
    <title>匿名函数变量赋值示例</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>

   <simpara>
    闭包可以从父作用域中继承变量。
   任何此类变量都应该用 <literal>use</literal> 语言结构传递进去。
    PHP 7.1 起，不能传入此类变量：  &link.superglobals;、 <varname>$this</varname> 或者和参数重名。
   </simpara>

   <example>
    <title>从父作用域继承变量</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// 没有 "use"
$example = function () {
    var_dump($message);
};
$example();

// 继承 $message
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Inherited variable's value is from when the function
// is defined, not when called
$message = 'world';
$example();

// Reset message
$message = 'hello';

// Inherit by-reference
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// The changed value in the parent scope
// is reflected inside the function call
$message = 'world';
$example();

// Closures can also accept regular arguments
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
]]>
    </screen>
   </example>

   <para>
    从 PHP 8.0.0 开始，作用域继承的变量列表可能包含一个尾部的逗号，这个逗号将被忽略。
   </para>
  <simpara>
    这些变量都必须在函数或类的头部声明。

    从父作用域中继承变量与使用全局变量是<emphasis>不同</emphasis>的。全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而
    闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。示例如下：
   </simpara>

   <example>
    <title>Closures 和作用域</title>
    <programlisting role="php">
<![CDATA[
<?php
// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。
// 其中有一个方法用来计算购物车中所有商品的总价格，该方法使
// 用了一个 closure 作为回调函数。
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();

    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }

    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }

    public function getTotal($tax)
    {
        $total = 0.00;

        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };

        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// 往购物车里添加条目
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// 打出出总价格，其中有 5% 的销售税.
print $my_cart->getTotal(0.05) . "\n";
// 最后结果是 54.29
?>
]]>
    </programlisting>
   </example>

   <example>
    <title>自动绑定 <literal>$this</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
   </example>

   <para>
    当在类的上下文中声明时，当前的类会自动与之绑定，使得
    <literal>$this</literal> 在函数的作用域中可用。如果不需要当前类的自动绑定，可以使用
    <link linkend="functions.anonymous-functions.static">静态匿名函数</link> 替代。
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>静态匿名函数</title>
    <para>
     匿名函数允许被定义为静态化。这样可以防止当前类自动绑定到它们身上，对象在运行时也可能不会被绑定到它们上面。
    </para>
    <para>
     <example>
      <title>试图在静态匿名函数中使用 <literal>$this</literal></title>
      <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>试图将对象绑定到静态匿名函数</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // function body
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
   </sect2>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.1.0</entry>
         <entry>
          Anonymous functions may not close over &link.superglobals;,
          <varname>$this</varname>, or any variable with the same name as a
          parameter.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      可以在闭包中使用
      <function>func_num_args</function>，<function>func_get_arg</function>
      和 <function>func_get_args</function>。
     </simpara>
    </note>
   </sect2>

  </sect1>
  <sect1 xml:id="functions.arrow">
   <title>箭头函数</title>

   <simpara>
    箭头函数是 PHP 7.4 的新语法，是一种更简洁的
    <link linkend="functions.anonymous">匿名函数</link> 写法。
   </simpara>
   <simpara>
    匿名函数和箭头函数都是
    <link linkend="class.closure"><classname>Closure</classname></link> 类的实现。
   </simpara>

   <simpara>
    箭头函数的基本语法为
    <code>fn (argument_list) =&gt; expr</code>。
   </simpara>

   <simpara>
    箭头函数支持与 <link linkend="functions.anonymous">匿名函数</link>
    相同的功能，只是其父作用域的变量总是自动的。
   </simpara>

   <simpara>
    当表达式中使用的变量是在父作用域中定义的，它将被隐式地按值捕获。在下面的例子中，函数
    <varname>$fn1</varname> 和 <varname>$fn2</varname> 的行为是一样的。
   </simpara>

   <para>
    <example>
     <title>箭头函数自动捕捉变量的值</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;

$fn1 = fn($x) => $x + $y;
// 相当于 using $y by value:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    在箭头函数嵌套的情况下同样有效。
   </simpara>
   <para>
    <example>
     <title>箭头函数自动捕捉变量的值，即使在嵌套的情况下</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// 输出 51
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    和匿名函数一样，箭头函数语法同样允许标准的函数声明，包括参数和返回类型、缺省值、变量，以及通过引用传递和返回。以下都是箭头函数的有效例子。
   </simpara>
   <para>
    <example>
     <title>合法的箭头函数例子</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    箭头函数会自动绑定上下文变量，这相当于对箭头函数内部使用的每一个变量 <varname>$x</varname> 执行了一个
    <code>use($x)</code>。这意味着不可能修改外部作用域的任何值，若要实现对值的修改，可以使用
    <link linkend="functions.anonymous">匿名函数</link> 来替代。
   </simpara>
   <para>
    <example>
     <title>来自外部范围的值不能在箭头函数内修改</title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // 不会影响 x 的值
$fn();
var_export($x);  // 输出 1

?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.4.0</entry>
         <entry>
          新增箭头函数语法。
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      可以对箭头函数使用 <function>func_num_args</function>,
      <function>func_get_arg</function>, 和 <function>func_get_args</function> 函数。
     </simpara>
    </note>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
