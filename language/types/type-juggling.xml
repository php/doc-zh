<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 4498e3ed8609b9d82f0afce49704de7d48364584 Maintainer: Avenger Status: ready -->
<!-- CREDITS: Geogory, dallas, Altair, mowangjuanzi, Luffy -->
<sect1 xml:id="language.types.type-juggling">
 <title>类型转换</title>

 <simpara>
  PHP 在变量声明时不需要定义类型。在这种情况下，变量的类型由存储的值决定。也就是说，如果
  <type>string</type> 赋值给 <varname>$var</varname>，然后 <varname>$var</varname>
  的类型就是 <type>string</type>。之后将 <type>int</type> 值赋值给 
  <varname>$var</varname>，它将是 <type>int</type> 类型。
 </simpara>

 <para>
  PHP 可能会尝试在某些上下文中自动将值转换为另一种类型。不同的上下文有：
  <itemizedlist>
   <listitem>
    <simpara>Numeric</simpara>
   </listitem>
   <listitem>
    <simpara>String</simpara>
   </listitem>
   <listitem>
    <simpara>Logical</simpara>
   </listitem>
   <listitem>
    <simpara>Integral and string</simpara>
   </listitem>
   <listitem>
    <simpara>Comparative</simpara>
   </listitem>
   <listitem>
    <simpara>Function</simpara>
   </listitem>
  </itemizedlist>
 </para>

 <note>
  <simpara>
   当值需要解释为不同类型时，值本身<emphasis>不</emphasis>会改变类型。
  </simpara>
 </note>

 <simpara>
  强制将变量当做某种变量来求值，参见<link linkend="language.types.typecasting">类型转换</link>一节。要更改变量的类型，请参阅
  <function>settype</function> 函数。
 </simpara>

 <sect2>
  <title>Numeric contexts</title>

  <simpara>
   This is the context when using an
   <link linkend="language.operators.arithmetic">arithmetical operator</link>.
  </simpara>

  <simpara>
   在这种情况下，如果任一运算对象是 <type>float</type>（或者不能解释为 <type>int</type>），则两个运算对象都将解释为
   <type>float</type>，结果也将是 <type>float</type>。否则，运算对象将解释为 <type>int</type>，结果也将是
   <type>int</type>。自 PHP 8.0.0 起，如果无法解释其中一个运算对象，则会抛出 <classname>TypeError</classname>。
  </simpara>
 </sect2>

 <sect2>
  <title>String contexts</title>

  <simpara>
   This is the context when using <function>echo</function>,
   <function>print</function>,
   <link linkend="language.types.string.parsing">string interpolation</link>,
   or the string
   <link linkend="language.operators.string">concatenation operator</link>.
  </simpara>

  <simpara>
   这种情况下，值将会解释为 <type>string</type>。如果值无法解释，那么会抛出
   <classname>TypeError</classname>。在 PHP 7.4.0 之前，会引发 <constant>E_RECOVERABLE_ERROR</constant>。
  </simpara>
 </sect2>

 <sect2>
  <title>Logical contexts</title>

  <simpara>
   This is the context when using conditional statements, the
   <link linkend="language.operators.comparison.ternary">ternary operator</link>,
   or a <link linkend="language.operators.logical">logical operator</link>.
  </simpara>

  <simpara>
   在这种情况下，值将会解释为 <type>bool</type>。
  </simpara>
 </sect2>

 <sect2>
  <title>Integral and string contexts</title>

  <simpara>
   This is the context when using a
   <link linkend="language.operators.bitwise">bitwise operators</link>.
  </simpara>

  <simpara>
   在这种情况下，如果所有的运算对象都是 <type>string</type>，则结果也将是
   <type>string</type>。否则运算对象将解释为 <type>int</type>，结果也将是
   <type>int</type>。如果其中一个运算对象无法解释，则会抛出 <classname>TypeError</classname>。
  </simpara>
 </sect2>

 <sect2>
  <title>Comparative contexts</title>

  <simpara>
   This is the context when using a
   <link linkend="language.operators.comparison">comparison operator</link>.
  </simpara>

  <simpara>
   在此上下文中发生的类型转换在比较多种类型<link
   linkend="language.operators.comparison.types">表</link>中进行了说明。
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.type-juggling.function">
  <title>Function contexts</title>

  <simpara>
   This is the context when a value is passed to a typed parameter, property,
   or returned from a function which declares a return type.
  </simpara>

  <para>
   在此上下文中，值必须是类型值。但存在两个例外，第一个是如果值为 <type>int</type>，但声明的类型是
   <type>float</type>，然后整数会转换为浮点数。第二个是如果声明的类型是 <emphasis>scalar</emphasis>
   <!-- e.g. An object that implements __toString will pass a string type -->
   类型，值可转换为标量类型，并且强制类型模式处于活动状态（默认），值会转换为可接受的标量值。参见下文查看有关此行为的描述。
  </para>

  <warning>
   <simpara>
    <link linkend="functions.internal">内部函数</link>自动将 &null;
    转换为标量类型，此行为自 PHP 8.1.0 起<emphasis>弃用</emphasis>。
   </simpara>
  </warning>

  <sect3 xml:id="language.types.type-juggling.function.simple">
   <title>使用简单类型声明的强制类型</title>
   <itemizedlist>
    <listitem>
     <simpara>
      <type>bool</type> 类型声明：值将解释为 <type>bool</type>。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>int</type> 类型声明：如果明确定义转换，则值将解释为 <type>int</type>。例如，字符串是<link
      linkend="language.types.numeric-strings">数字</link>。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>float</type> 类型声明：如果明确定义转换，则值将解释为 <type>float</type>。例如，字符串是<link
      linkend="language.types.numeric-strings">数字</link>。
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>string</type> 类型声明：值将解释为 <type>string</type>。
     </simpara>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3 xml:id="language.types.type-juggling.function.union">
   <title>使用联合类型的强制类型</title>
   <para>
    When <literal>strict_types</literal> is not enabled, scalar type declarations
    are subject to limited implicit type coercions.
    如果值的精确类型不是联合的一部分，然后会按照以下优先顺序选择目标类型：

    <orderedlist>
     <listitem>
      <simpara>
       <type>int</type>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <type>float</type>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <type>string</type>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <type>bool</type>
      </simpara>
     </listitem>
    </orderedlist>

    If the type exists in the union and the value can be coerced to the
    type under PHP's existing type-checking semantics, then the type is chosen.
    Otherwise, the next type is tried.
   </para>

   <caution>
    <para>
     一个例外，如果值是字符串，并且 int 和 float 都是联合类型的一部分，首选类型则通过现有的<link
     linkend="language.types.numeric-strings">数字字符串</link>语义决定。例如
     <literal>"42"</literal> 选择 <type>int</type>，<literal>"42.0"</literal> 选择 <type>float</type>。
    </para>
   </caution>

   <note>
    <para>
     Types that are not part of the above preference list are not eligible
     targets for implicit coercion. In particular no implicit coercions to
     the <type>null</type>, <type>false</type>, and <type>true</type>
     types occur.
    </para>
   </note>

   <example>
    <title>Example of types being coerced into a type part of the union</title>
    <programlisting role="php">
<![CDATA[
<?php
// int|string
42    --> 42          // exact type
"42"  --> "42"        // exact type
new ObjectWithToString --> "Result of __toString()"
                      // object never compatible with int, fall back to string
42.0  --> 42          // float compatible with int
42.1  --> 42          // float compatible with int
1e100 --> "1.0E+100"  // float too large for int type, fall back to string
INF   --> "INF"       // float too large for int type, fall back to string
true  --> 1           // bool compatible with int
[]    --> TypeError   // array not compatible with int or string

// int|float|bool
"45"    --> 45        // int numeric string
"45.0"  --> 45.0      // float numeric string

"45X"   --> true      // not numeric string, fall back to bool
""      --> false     // not numeric string, fall back to bool
"X"     --> true      // not numeric string, fall back to bool
[]      --> TypeError // array not compatible with int, float or bool
?>
]]>
    </programlisting>
   </example>
  </sect3>

 </sect2>

 <sect2 xml:id="language.types.typecasting">
  <title>类型转换</title>

  <simpara>
   类型转换通过在值前面的括号中写入类型来将值转换指定的类型。
  </simpara>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo 是 int
$bar = (bool) $foo;   // $bar 是 bool
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   允许的转换是：
  </simpara>

  <simplelist>
   <member><literal>(int)</literal> ——转换为 <type>int</type></member>
   <member><literal>(bool)</literal> ——转换为 <type>bool</type></member>
   <member><literal>(float)</literal> ——转换为 <type>float</type></member>
   <member><literal>(string)</literal> ——转换为 <type>string</type></member>
   <member><literal>(array)</literal> ——转换为 <type>array</type></member>
   <member><literal>(object)</literal> ——转换为 <type>object</type></member>
   <member><literal>(unset)</literal> ——转换为 <type>NULL</type></member>
  </simplelist>

  <note>
   <para>
    <literal>(integer)</literal> 是 <literal>(int)</literal> 转换的别名。<literal>(boolean)</literal>
    是 <literal>(bool)</literal> 转换的别名。<literal>(binary)</literal> 是 <literal>(string)</literal>
    转换的别名。<literal>(double)</literal> 和 <literal>(real)</literal> 是 <literal>(float)</literal>
    转换的别名。这些转换不使用标准的类型名称，不推荐使用。
   </para>
  </note>

  <warning>
   <simpara>
    自 PHP 8.0.0 起弃用 <literal>(real)</literal> 转换别名。
   </simpara>
  </warning>

  <warning>
   <simpara>
    自 PHP 7.2.0 起弃用 <literal>(unset)</literal> 转换。注意
    <literal>(unset)</literal> 转换等同于将值 <type>NULL</type> 
    通过赋值或者调用给变量。自 PHP 8.0.0 起移除 <literal>unset</literal> 转换。
   </simpara>
  </warning>

  <caution>
   <simpara>
    向前兼容 <literal>(binary)</literal> 转换和 <literal>b</literal>
    前缀转换。注意 <literal>(binary)</literal> 转换和 <literal>(string)</literal>
    相同，但是这可能会改变且不应依赖。
   </simpara>
  </caution>

  <note>
   <para>
    在转换的括号内忽略空格。因此，以下两个转换是等价的：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>

  <informalexample>
   <simpara>
    将文字 <type>string</type> 和变量转换为二进制 <type>string</type>：
   </simpara>

   <programlisting role="php">
<![CDATA[
<?php
$binary = (binary) $string;
$binary = b"binary string";
?>
]]>
   </programlisting>
  </informalexample>

  <!-- TODO Remove or move into string context section? -->
  <note>
   <simpara>
    除了将变量转换为 <type>string</type> 之外，还可以将变量放在双引号内。
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo 是 int
$str = "$foo";        // $str 是 string
$fst = (string) $foo; // $fst 也是 string

// 打印出 "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
    </programlisting>
   </informalexample>
  </note>
   
  <para>
   有时在类型之间转换时确切地会发生什么可能不是很明显。更多信息见如下不分：
   <simplelist>
    <member><link linkend="language.types.boolean.casting">转换为 bool</link></member>
    <member><link linkend="language.types.integer.casting">转换为 int</link></member>
    <member><link linkend="language.types.float.casting">转换为 float</link></member>
    <member><link linkend="language.types.string.casting">转换为 string</link></member>
    <member><link linkend="language.types.array.casting">转换为 array</link></member>
    <member><link linkend="language.types.object.casting">转换为 object</link></member>
    <member><link linkend="language.types.resource.casting">转换为 resource</link></member>
    <member><link linkend="language.types.null.casting">转换为 NULL</link></member>
    <member><link linkend="types.comparisons">类型比较表</link></member>
   </simplelist>
  </para>
 </sect2>

 <simplesect>
  <note>
   <simpara>
    因为 PHP 的 <type>string</type> 支持使用与 <type>array</type>
    索引相同的语法，通过偏移量进行索引，所以以下示例适用于所有 PHP 版本：
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a    = 'car'; // $a 是 string
$a[0] = 'b';   // $a 依然是 string
echo $a;       // bar
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    请查看章节标题为<link linkend="language.types.string.substr">存取和修改字符串中的字符</link>获取更多信息。
   </simpara>
  </note>
 </simplesect>

</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
