<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: e2f53f0f601cd3e97ebdb516e51de1825d0106ea Maintainer: Avenger Status: ready -->
<!-- CREDITS: Geogory, dallas, Altair, mowangjuanzi -->
<sect1 xml:id="language.types.type-juggling">
 <title>Type Juggling</title>

 <simpara>
  PHP 在变量声明时不需要定义类型。在这种情况下，变量的类型由存储的值决定。也就是说，如果给变量
  <varname>$var</varname> 赋值 <type>string</type>，然后 <varname>$var</varname>
  的类型就是 <type>string</type>。之后将 <type>int</type> 值赋值给 
  <varname>$var</varname>，它将是 <type>int</type> 类型。
 </simpara>

 <para>
  PHP 可能会尝试在某些上下文中自动将值转换为另一种类型。不同的上下文下列这些：
  <itemizedlist>
   <listitem>
    <simpara>Numeric</simpara>
   </listitem>
   <listitem>
    <simpara>String</simpara>
   </listitem>
   <listitem>
    <simpara>Logical</simpara>
   </listitem>
   <listitem>
    <simpara>Integral and string</simpara>
   </listitem>
   <listitem>
    <simpara>Comparative</simpara>
   </listitem>
   <listitem>
    <simpara>Function</simpara>
   </listitem>
  </itemizedlist>
 </para>

 <note>
  <simpara>
   当值需要解释为不同类型时，值本身<emphasis>不</emphasis>会改变类型。
  </simpara>
 </note>

 <simpara>
  强制将变量当做某种变量来求职，参见<link linkend="language.types.typecasting">类型强制转换</link>一节。要更改变量的类型，请参阅
  <function>settype</function> 函数。
 </simpara>

 <sect2>
  <title>Numeric contexts</title>

  <simpara>
   This is the context when using an
   <link linkend="language.operators.arithmetic">arithmetical operator</link>.
  </simpara>

  <simpara>
   在这种情况下，如果任一运算对象是 <type>float</type>（或者不能解释为 <type>int</type>），则两个运算对象都将解释为
   <type>float</type>，结果也将是 <type>float</type>。否则，运算对象将解释为 <type>int</type>，结果也将是
   <type>int</type>。自 PHP 8.0.0 起，如果无法解释其中一个运算对象，则会抛出 <classname>TypeError</classname>。
  </simpara>
 </sect2>

 <sect2>
  <title>String contexts</title>

  <simpara>
   This is the context when using <function>echo</function>,
   <function>print</function>,
   <link linkend="language.types.string.parsing">string interpolation</link>,
   or the string
   <link linkend="language.operators.string">concatenation operator</link>.
  </simpara>

  <simpara>
   这种情况下，值将会解释为 <type>string</type>。
  </simpara>
 </sect2>

 <sect2>
  <title>Logical contexts</title>

  <simpara>
   This is the context when using conditional statements, the
   <link linkend="language.operators.comparison.ternary">ternary operator</link>,
   or a <link linkend="language.operators.logical">logical operator</link>.
  </simpara>

  <simpara>
   在这种情况下，值将会解释为 <type>bool</type>。
  </simpara>
 </sect2>

 <sect2>
  <title>Integral and string contexts</title>

  <simpara>
   This is the context when using a
   <link linkend="language.operators.bitwise">bitwise operators</link>.
  </simpara>

  <simpara>
   在这种情况下，如果所有的运算对象都是 <type>string</type>，则结果也将是
   <type>string</type>。否则运算对象将解释为 <type>int</type>，结果也将是
   <type>int</type>。如果其中一个运算对象无法解释，则会抛出 <classname>TypeError</classname>。
  </simpara>
 </sect2>

 <sect2>
  <title>Comparative contexts</title>

  <simpara>
   This is the context when using a
   <link linkend="language.operators.comparison">comparison operator</link>.
  </simpara>

  <simpara>
   在此上下文中发生的类型转换在比较多种类型<link
   linkend="language.operators.comparison.types">表</link>中进行了说明。
  </simpara>
 </sect2>

 <sect2>
  <title>Function contexts</title>

  <simpara>
   This is the context when a value is passed to a typed parameter, property,
   or returned from a function which declares a return type.
  </simpara>

  <para>
   In this context, when coercive typing mode is active (the default),
   only scalar values may be converted to another scalar value.
   For simple types declarations the behaviour is as follows:
   <itemizedlist>
    <listitem>
     <simpara>
      <type>bool</type> type declaration: value is interpreted as <type>bool</type>.
     </simpara>
     <simpara>
      <type>int</type> type declaration: value is interpreted as <type>int</type>
      if conversion is well-defined. I.e. the string is
      <link linkend="language.types.numeric-strings">numeric</link>.
     </simpara>
     <simpara>
      <type>float</type> type declaration: value is interpreted as <type>float</type>
      if conversion is well-defined. I.e. the string is
      <link linkend="language.types.numeric-strings">numeric</link>.
     </simpara>
     <simpara>
      <type>string</type> type declaration: value is interpreted as <type>string</type>.
     </simpara>
    </listitem>
   </itemizedlist>

   If the type declaration is a union, see the section about
   <link linkend="language.types.declarations.union.coercive">Coercive typing with union types</link>.
  </para>

  <warning>
   <simpara>
    自 PHP 8.1.0 起弃用<link linkend="functions.internal">内部函数</link>自动将
    &null; 转换为标量类型的行为。
   </simpara>
  </warning>
 </sect2>

 <sect2 xml:id="language.types.typecasting">
  <title>类型强制转换</title>

  <simpara>
   类型强制转换通过在值前面的括号中写入类型来将值转换指定的类型。
  </simpara>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo is an integer
$bar = (bool) $foo;   // $bar is a boolean
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   The casts allowed are:
  </simpara>

  <simplelist>
   <member><literal>(int)</literal> ——强制转换为 <type>int</type></member>
   <member><literal>(bool)</literal> ——强制转换为 <type>bool</type></member>
   <member><literal>(float)</literal> ——强制转换为 <type>float</type></member>
   <member><literal>(string)</literal> ——强制转换为 <type>string</type></member>
   <member><literal>(array)</literal> ——强制转换为 <type>array</type></member>
   <member><literal>(object)</literal> ——强制转换为 <type>object</type></member>
   <member><literal>(unset)</literal> ——强制转换为 <type>NULL</type></member>
  </simplelist>

  <note>
   <para>
    <literal>(integer)</literal> is an alias of the <literal>(int)</literal> cast.
    <literal>(boolean)</literal> is an alias of the <literal>(bool)</literal> cast.
    <literal>(binary)</literal> is an alias of the <literal>(string)</literal> cast.
    <literal>(double)</literal> and <literal>(real)</literal> are aliases of
    the <literal>(float)</literal> cast.
    These casts do not use the canonical type name and are not recommended.
   </para>
  </note>

  <warning>
   <simpara>
    The <literal>(real)</literal> cast alias has been deprecated as of PHP 8.0.0.
   </simpara>
  </warning>

  <warning>
   <simpara>
    The <literal>(unset)</literal> cast has been deprecated as of PHP 7.2.0.
    Note that the <literal>(unset)</literal> cast is the same as assigning the
    value <type>NULL</type> to the variable or call.
    The <literal>(unset)</literal> cast is removed as of PHP 8.0.0.
   </simpara>
  </warning>

  <caution>
   <simpara>
    The <literal>(binary)</literal> cast and <literal>b</literal> prefix exists
    for forward support. Currently <literal>(binary)</literal> and
    <literal>(string)</literal> are identical, however this may change and
    should not be relied upon.
   </simpara>
  </caution>

  <note>
   <para>
    Whitespaces are ignored within the parentheses of a cast.
    Therefore, the following are two casts are equivalent:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>

  <informalexample>
   <simpara>
    Casting literal <type>string</type>s and variables to binary
    <type>string</type>s:
   </simpara>

   <programlisting role="php">
<![CDATA[
<?php
$binary = (binary) $string;
$binary = b"binary string";
?>
]]>
   </programlisting>
  </informalexample>

  <!-- TODO Remove or move into string context section? -->
  <note>
   <simpara>
    Instead of casting a variable to a <type>string</type>, it is also possible
    to enclose the variable in double quotes.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
    </programlisting>
   </informalexample>
  </note>
   
  <para>
   It may not be obvious exactly what will happen when casting between certain
   types. For more information, see these sections:
   <simplelist>
    <member><link linkend="language.types.boolean.casting">Converting to boolean</link></member>
    <member><link linkend="language.types.integer.casting">Converting to integer</link></member>
    <member><link linkend="language.types.float.casting">Converting to float</link></member>
    <member><link linkend="language.types.string.casting">Converting to string</link></member>
    <member><link linkend="language.types.array.casting">Converting to array</link></member>
    <member><link linkend="language.types.object.casting">Converting to object</link></member>
    <member><link linkend="language.types.resource.casting">Converting to resource</link></member>
    <member><link linkend="language.types.null.casting">Converting to NULL</link></member>
    <member><link linkend="types.comparisons">The type comparison tables</link></member>
   </simplelist>
  </para>
 </sect2>

 <simplesect>
  <note>
   <simpara>
    Because PHP supports indexing into <type>string</type>s via offsets
    using the same syntax as <type>array</type> indexing, the following example
    holds true for all PHP versions:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a    = 'car'; // $a is a string
$a[0] = 'b';   // $a is still a string
echo $a;       // bar
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    See the section titled <link linkend="language.types.string.substr">String
    access by character</link> for more information.
   </simpara>
  </note>
 </simplesect>

</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
