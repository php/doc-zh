<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: cd2980a57a0845def25ed84276d9662159a91bd5 Maintainer: mowangjuanzi Status: ready -->
<sect1 xml:id="language.oop5.property-hooks" xmlns="http://docbook.org/ns/docbook">
 <title>属性钩子</title>

 <simpara>
  属性钩子在某些其他语言中也被称为"属性访问器"，是一种拦截和覆盖属性读写行为的方式。此功能有两个用途：
 </simpara>
 <orderedlist>
  <listitem>
   <simpara>
    允许直接使用属性，而不需要 get 和 set 方法，同时保留在未来添加额外行为的可能性。这使得大多数样板式的 get/set 方法变得不再必要，即使不使用钩子也是如此。
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    允许属性描述对象而不需要直接存储值。
   </simpara>
  </listitem>
 </orderedlist>
 <simpara>
  非静态属性有两个可用的钩子：<literal>get</literal> 和 <literal>set</literal>，分别用于覆盖属性的读取和写入行为。钩子可用于有类型和无类型的属性。
 </simpara>
 <simpara>
  属性可以是"backed"（有后备存储）或"virtual"（虚拟的）。backed 属性是实际存储值的属性，任何没有钩子的属性都是 backed 属性。虚拟属性是具有钩子且这些钩子不与属性本身交互的属性。在这种情况下，钩子实际上等同于方法，对象不会为该属性使用任何内存空间来存储值。
 </simpara>
 <simpara>
  属性钩子与 <literal>readonly</literal> 属性不兼容。如果需要在更改行为的同时限制对 <literal>get</literal> 或 <literal>set</literal> 操作的访问，请使用<link linkend="language.oop5.visibility-members-aviz">非对称属性可见性</link>。
 </simpara>

 <note>
  <title>版本信息</title>
  <simpara>
   属性钩子在 PHP 8.4 中引入。
  </simpara>
 </note>

 <sect2>
  <title>基本钩子语法</title>
  <simpara>
   声明钩子的通用语法如下。
  </simpara>
  <example>
   <title>属性钩子（完整版本）</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    private bool $modified = false;

    public string $foo = 'default value' {
        get {
            if ($this->modified) {
                return $this->foo . ' (modified)';
            }
            return $this->foo;
        }
        set(string $value) {
            $this->foo = strtolower($value);
            $this->modified = true;
        }
    }
}

$example = new Example();
$example->foo = 'changed';
print $example->foo;
?>
]]>
   </programlisting>
  </example>
  <simpara>
   <varname>$foo</varname> 属性以 <literal>{}</literal> 结尾，而不是分号，这表示存在钩子。同时定义了 <literal>get</literal> 和 <literal>set</literal> 钩子，但也允许只定义其中一个。两个钩子都有一个由 <literal>{}</literal> 表示的主体，可以包含任意代码。
  </simpara>
  <simpara>
   <literal>set</literal> 钩子还允许使用与方法相同的语法指定传入值的类型和名称。类型必须与属性的类型相同，或者对其<link linkend="language.oop5.variance.contravariance">逆变</link>（更宽泛）。例如，<type>string</type> 类型的属性可以有一个接受 <type class="union"><type>string</type><type>Stringable</type></type> 的 <literal>set</literal> 钩子，但不能有一个仅接受 <type>array</type> 的钩子。
  </simpara>
  <simpara>
   至少有一个钩子引用了 <code>$this->foo</code>，即属性本身。这意味着该属性将是"backed"的。当调用 <code>$example->foo = 'changed'</code> 时，提供的字符串将首先被转换为小写，然后保存到后备值中。当读取属性时，之前保存的值可能会有条件地附加额外的文本。
  </simpara>
  <simpara>
   还有许多简写语法变体可用于处理常见情况。
  </simpara>
  <simpara>
   如果 <literal>get</literal> 钩子是单个表达式，则可以省略 <literal>{}</literal>，替换为箭头表达式。
  </simpara>
  <example>
   <title>属性 get 表达式</title>
   <simpara>
    此示例与前一个等价。
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    private bool $modified = false;

    public string $foo = 'default value' {
        get => $this->foo . ($this->modified ? ' (modified)' : '');

        set(string $value) {
            $this->foo = strtolower($value);
            $this->modified = true;
        }
    }
}
?>
]]>
   </programlisting>
  </example>
  <simpara>
   如果 <literal>set</literal> 钩子的参数类型与属性类型相同（通常如此），则可以省略。在这种情况下，要设置的值会自动命名为 <varname>$value</varname>。
  </simpara>
  <example>
   <title>属性 set 默认值</title>
   <simpara>
    此示例与前一个等价。
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    private bool $modified = false;

    public string $foo = 'default value' {
        get => $this->foo . ($this->modified ? ' (modified)' : '');

        set {
            $this->foo = strtolower($value);
            $this->modified = true;
        }
    }
}
?>
]]>
   </programlisting>
  </example>
  <simpara>
   如果 <literal>set</literal> 钩子只是设置传入值的修改版本，那么也可以将其简化为箭头表达式。表达式求值的结果将被设置到后备值上。
  </simpara>
  <example>
   <title>属性 set 表达式</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    public string $foo = 'default value' {
        get => $this->foo . ($this->modified ? ' (modified)' : '');
        set => strtolower($value);
    }
}
?>
]]>
   </programlisting>
  </example>
  <simpara>
   此示例与前一个并不完全等价，因为它没有修改 <code>$this->modified</code>。如果 set 钩子主体中需要多条语句，请使用大括号版本。
  </simpara>
  <simpara>
   属性可以根据需要实现零个、一个或两个钩子。所有简写版本都是相互独立的。也就是说，使用简写 get 搭配完整 set，或者使用简写 set 搭配显式类型，等等都是合法的。
  </simpara>
  <simpara>
   对于 backed 属性，省略 <literal>get</literal> 或 <literal>set</literal> 钩子意味着将使用默认的读取或写入行为。
  </simpara>
  <note>
   <simpara>
    钩子可以在使用<link linkend="language.oop5.decon.constructor.promotion">构造函数属性提升</link>时定义。但是，这样做时，提供给构造函数的值必须与属性关联的类型匹配，无论 <literal>set</literal> 钩子允许什么。
   </simpara>
   <simpara>
    考虑以下示例：
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    public function __construct(
        public private(set) DateTimeInterface $created {
            set (string|DateTimeInterface $value) {
                if (is_string($value)) {
                    $value = new DateTimeImmutable($value);
                }
                $this->created = $value;
            }
        },
    ) {
    }
}
]]>
   </programlisting>
   <simpara>
    引擎内部会将其分解为以下形式：
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    public private(set) DateTimeInterface $created {
        set (string|DateTimeInterface $value) {
            if (is_string($value)) {
                $value = new DateTimeImmutable($value);
            }
            $this->created = $value;
        }
    }

    public function __construct(
        DateTimeInterface $created,
    ) {
        $this->created = $created;
    }
}
]]>
   </programlisting>
   <simpara>
    在构造函数之外设置属性时，将允许 <type>string</type> 或 <interfacename>DateTimeInterface</interfacename> 值，但构造函数只接受 <interfacename>DateTimeInterface</interfacename>。这是因为属性定义的类型（<interfacename>DateTimeInterface</interfacename>）被用作构造函数签名中的参数类型，无论 <literal>set</literal> 钩子允许什么。
   </simpara>
   <simpara>
    如果需要在构造函数中实现这种行为，则不能使用构造函数属性提升。
   </simpara>
  </note>
 </sect2>
 <sect2 xml:id="language.oop5.property-hooks.virtual">
  <title>虚拟属性</title>
  <simpara>
   虚拟属性是没有后备值的属性。如果属性的 <literal>get</literal> 和 <literal>set</literal> 钩子都没有使用精确语法引用属性本身，则该属性就是虚拟的。也就是说，名为 <code>$foo</code> 的属性如果其钩子中包含 <code>$this->foo</code>，则是 backed 属性。但以下不是 backed 属性，将会报错：
  </simpara>
  <example>
   <title>无效的虚拟属性</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    public string $foo {
        get {
            $temp = __PROPERTY__;
            return $this->$temp; // Doesn't refer to $this->foo, so it doesn't count.
        }
    }
}
?>
]]>
   </programlisting>
  </example>
  <simpara>
   对于虚拟属性，如果省略了某个钩子，那么该操作就不存在，尝试使用它将产生错误。虚拟属性不占用对象中的内存空间。虚拟属性适用于"派生"属性，例如由其他两个属性组合而成的属性。
  </simpara>
  <example>
   <title>虚拟属性</title>
   <programlisting role="php">
<![CDATA[
<?php
class Rectangle
{
    // A virtual property.
    public int $area {
        get => $this->h * $this->w;
    }

    public function __construct(public int $h, public int $w) {}
}

$s = new Rectangle(4, 5);
print $s->area; // prints 20
$s->area = 30; // Error, as there is no set operation defined.
?>
]]>
   </programlisting>
  </example>
  <simpara>
   在虚拟属性上同时定义 <literal>get</literal> 和 <literal>set</literal> 钩子也是允许的。
  </simpara>
 </sect2>
 <sect2>
  <title>作用域</title>
  <simpara>
   所有钩子都在被修改对象的作用域内运行。这意味着它们可以访问对象的所有 public、private 或 protected 方法，以及所有 public、private 或 protected 属性，包括可能有自己属性钩子的属性。从钩子中访问另一个属性不会绕过该属性上定义的钩子。
  </simpara>
  <simpara>
   最值得注意的含义是，非简单的钩子可以根据需要调用任意复杂的方法。
  </simpara>
  <example>
   <title>从钩子中调用方法</title>
   <programlisting role="php">
<![CDATA[
<?php
class Person {
    public string $phone {
        set => $this->sanitizePhone($value);
    }

    private function sanitizePhone(string $value): string {
        $value = ltrim($value, '+');
        $value = ltrim($value, '1');

        if (!preg_match('/\d\d\d\-\d\d\d\-\d\d\d\d/', $value)) {
            throw new \InvalidArgumentException();
        }
        return $value;
    }
}
?>
]]>
   </programlisting>
  </example>
 </sect2>
 <sect2>
  <title>引用</title>
  <simpara>
   由于钩子的存在会拦截属性的读写过程，因此在获取属性的引用或进行间接修改（如 <code>$this->arrayProp['key'] = 'value';</code>）时会产生问题。这是因为任何通过引用修改值的尝试都会绕过 set 钩子（如果定义了的话）。
  </simpara>
  <simpara>
   在极少数需要获取定义了钩子的属性的引用的情况下，可以在 <literal>get</literal> 钩子前加上 <literal>&amp;</literal> 前缀，使其按引用返回。在同一属性上同时定义 <literal>get</literal> 和 <literal>&amp;get</literal> 是语法错误。
  </simpara>
  <simpara>
   不允许在 backed 属性上同时定义 <literal>&amp;get</literal> 和 <literal>set</literal> 钩子。如上所述，通过引用写入返回的值会绕过 <literal>set</literal> 钩子。在虚拟属性上，两个钩子之间没有必然共享的值，因此允许同时定义两者。
  </simpara>
  <simpara>
   写入数组属性的索引也涉及隐式引用。因此，只有在仅定义了 <literal>&amp;get</literal> 钩子的情况下，才允许写入带有钩子的 backed 数组属性。在虚拟属性上，写入从 <literal>get</literal> 或 <literal>&amp;get</literal> 返回的数组是合法的，但这是否对对象产生影响取决于钩子的实现。
  </simpara>
  <simpara>
   覆盖整个数组属性是可以的，行为与其他任何属性相同。只有操作数组元素时需要特别注意。
  </simpara>
 </sect2>
 <sect2>
  <title>继承</title>
  <sect3>
   <title>Final 钩子</title>
   <simpara>
    钩子也可以声明为 <link linkend="language.oop5.final">final</link>，在这种情况下不能被覆盖。
   </simpara>
   <example>
    <title>Final 钩子</title>
    <programlisting role="php">
<![CDATA[
<?php
class User
{
    public string $username {
        final set => strtolower($value);
    }
}

class Manager extends User
{
    public string $username {
        // This is allowed
        get => strtoupper($this->username);

        // But this is NOT allowed, because set is final in the parent.
        set => strtoupper($value);
    }
}
?>
]]>
    </programlisting>
   </example>
   <simpara>
    属性也可以声明为 <link linkend="language.oop5.final">final</link>。final 属性不能被子类以任何方式重新声明，这包括修改钩子或扩大其访问权限。
   </simpara>
   <simpara>
    在声明为 final 的属性上将钩子声明为 final 是多余的，会被静默忽略。这与 final 方法的行为一致。
   </simpara>
   <simpara>
    子类可以通过重新声明属性并只定义要覆盖的钩子来定义或重新定义各个钩子。子类也可以向之前没有钩子的属性添加钩子。这本质上与钩子是方法时的行为相同。
   </simpara>
   <example>
    <title>钩子继承</title>
    <programlisting role="php">
<![CDATA[
<?php
class Point
{
    public int $x;
    public int $y;
}

class PositivePoint extends Point
{
    public int $x {
        set {
            if ($value < 0) {
                throw new \InvalidArgumentException('Too small');
            }
            $this->x = $value;
        }
    }
}
?>
]]>
    </programlisting>
   </example>
   <simpara>
    每个钩子独立于其他钩子覆盖父类的实现。如果子类添加了钩子，属性上设置的任何默认值都会被移除，必须重新声明。这与无钩子属性的继承方式一致。
   </simpara>
  </sect3>
  <sect3>
   <title>访问父类钩子</title>
   <simpara>
    子类中的钩子可以使用 <code>parent::$prop</code> 关键字后跟所需的钩子来访问父类的属性。例如，<code>parent::$propName::get()</code>。可以理解为"访问父类中定义的 <varname>prop</varname>，然后运行其 get 操作"（或 set 操作，视情况而定）。
   </simpara>
   <simpara>
    如果不以这种方式访问，父类的钩子将被忽略。这一行为与所有方法的工作方式一致。这也提供了一种访问父类存储（如果有的话）的方式。如果父属性上没有钩子，则会使用其默认的 get/set 行为。钩子不能访问除自身属性上的父钩子之外的任何其他钩子。
   </simpara>
   <simpara>
    上面的示例可以重写如下，这将允许 <literal>Point</literal> 类在未来添加自己的 <literal>set</literal> 钩子而不会产生问题（在前面的示例中，添加到父类的钩子会在子类中被忽略）。
   </simpara>
   <example>
    <title>访问父类钩子（set）</title>
    <programlisting role="php">
<![CDATA[
<?php
class Point
{
    public int $x;
    public int $y;
}

class PositivePoint extends Point
{
    public int $x {
        set {
            if ($value < 0) {
                throw new \InvalidArgumentException('Too small');
            }
            parent::$x::set($value);
        }
    }
}
?>
]]>
    </programlisting>
   </example>
   <simpara>
    仅覆盖 get 钩子的示例如下：
   </simpara>
   <example>
    <title>访问父类钩子（get）</title>
    <programlisting role="php">
<![CDATA[
<?php
class Strings
{
    public string $val;
}

class CaseFoldingStrings extends Strings
{
    public bool $uppercase = true;

    public string $val {
        get => $this->uppercase
            ? strtoupper(parent::$val::get())
            : strtolower(parent::$val::get());
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect3>
 </sect2>
 <sect2>
  <title>序列化</title>
  <simpara>
   PHP 有多种不同的方式可以序列化对象，用于公共使用或调试目的。钩子的行为因使用场景而异。在某些情况下，会使用属性的原始后备值，绕过所有钩子。在其他情况下，属性将"通过"钩子进行读取或写入，就像任何其他正常的读写操作一样。
  </simpara>
  <simplelist>
   <member><function>var_dump</function>：使用原始值</member>
   <member><function>serialize</function>：使用原始值</member>
   <member><function>unserialize</function>：使用原始值</member>
   <member><link linkend="object.serialize">__serialize()</link>/<link linkend="object.unserialize">__unserialize()</link>：自定义逻辑，使用 get/set 钩子</member>
   <member>数组转换：使用原始值</member>
   <member><function>var_export</function>：使用 get 钩子</member>
   <member><function>json_encode</function>：使用 get 钩子</member>
   <member><interfacename>JsonSerializable</interfacename>：自定义逻辑，使用 get 钩子</member>
   <member><function>get_object_vars</function>：使用 get 钩子</member>
   <member><function>get_mangled_object_vars</function>：使用原始值</member>
  </simplelist>
 </sect2>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
